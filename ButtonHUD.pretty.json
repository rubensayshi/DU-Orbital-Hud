{
  "slots": {
    "-1": {
      "name": "unit",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-2": {
      "name": "system",
      "type": {
        "events": [],
        "methods": []
      }
    },
    "-3": {
      "name": "library",
      "type": {
        "events": [],
        "methods": []
      }
    }
  },
  "handlers": [
    {
      "code": "-- !DU[lib]: exports\n\n-- USER DEFINABLE GLOBAL AND LOCAL VARIABLES THAT SAVE\nAutopilotTargetOrbit = 100000 --export: How far you want the orbit to be from the planet in m.  200,000 = 1SU\nwarmup = 32 --export: How long it takes your engines to warmup.  Basic Space Engines, from XS to XL: 0.25,1,4,16,32\nPrimaryR = 130 --export: Primary HUD color\nPrimaryG = 224 --export: Primary HUD color\nPrimaryB = 255 --export: Primary HUD color\nuserControlScheme = \"Keyboard\" --export: Set to \"Virtual Joystick\", \"Mouse\", or \"Keyboard\"\nfreeLookToggle = true --export: Set to false for default free look behavior.\nbrakeToggle = true --export: Set to false to use hold to brake vice toggle brake.\napTickRate = 0.0166667 --export: Set the Tick Rate for your HUD.  0.016667 is effectively 60 fps and the default value. 0.03333333 is 30 fps.  The bigger the number the less often the autopilot and hud updates but may help peformance on slower machings.\nMaxGameVelocity = 8333.05 --export: Max speed for your autopilot in m/s, do not go above 8333.055 (30000 km/hr), use 6944.4444 for 25000km/hr\nAutoTakeoffAltitude = 1000 --export: How high above your starting position AutoTakeoff tries to put you\nDeadZone = 50 --export: Number of pixels of deadzone at the center of the screen\nMouseYSensitivity = 0.003 --export:1 For virtual joystick only\nMouseXSensitivity = 0.003 --export: For virtual joystick only\ncircleRad = 99 --export: The size of the artifical horizon circle, set to 0 to remove.\nautoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)\nshowHud = true --export: Uncheck to hide the HUD and only use autopilot features via ALT+# keys.\nhideHudOnToggleWidgets = true --export: Uncheck to keep showing HUD when you toggle on the widgets via ALT+3.\nfuelTankOptimization = 0 --export: For accurate fuel levels, set this to the fuel tank optimization level * 0.05 (so level 1 = 0.05, level 5 = 0.25) of the person who placed the tank. This will be 0 for most people for now.\nRemoteFreeze = false --export: Whether or not to freeze you when using a remote controller.  Breaks some things, only freeze on surfboards\npitchSpeedFactor = 0.8 --export: For keyboard control\nyawSpeedFactor =  1 --export: For keyboard control\nrollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nbrakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nbrakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nautoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01\nturnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is\nturnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nTargetHoverHeight = 50 --export: Hover height when retracting landing gear\nAutopilotInterplanetaryThrottle = 100 --export: How much throttle, in percent, you want it to use when autopiloting to another planet\nShiftShowsRemoteButtons = true --export: Whether or not pressing Shift in remote controller mode shows you the buttons (otherwise no access to them)\nDampingMultiplier = 40 --export: How strongly autopilot dampens when nearing the correct orientation\nspeedChangeLarge = 5 --export: The speed change that occurs when you tap speed up/down, default is 5 (25% throttle change). \nspeedChangeSmall = 1 --export: the speed change that occurs while you hold speed up/down, default is 1 (5% throttle change).\nbrightHud = false --export: Enable to prevent hud dimming when in freelook.\n-- !DU[lib]: consts\n\n-- !DU[lib]: kinematic\n\nfunction Kinematics()\n    local Kinematic = {} -- just a namespace\n    local C       = 30000000/3600\n    local C2      = C*C\n    local ITERATIONS = 100 -- iterations over engine \"warm-up\" period\n    local function lorentz(v) return 1/math.sqrt(1 - v*v/C2) end\n\n    function Kinematic.computeAccelerationTime(initial, acceleration, final)\n        -- The low speed limit of following is: t=(vf-vi)/a (from: vf=vi+at)\n        local k1 = C*math.asin(initial/C)\n        return (C * math.asin(final/C) - k1)/acceleration\n    end\n\n    function Kinematic.computeDistanceAndTime(initial,\n                                              final,\n                                              restMass,\n                                              thrust,\n                                              t50,\n                                              brakeThrust)\n\n        t50            = t50 or 0\n        brakeThrust    = brakeThrust or 0 -- usually zero when accelerating\n        local tau0     = lorentz(initial)\n        local speedUp  = initial <= final\n        local a0       = thrust * (speedUp and 1 or -1)/restMass\n        local b0       = -brakeThrust/restMass\n        local totA     = a0+b0\n        if speedUp and totA <= 0 or not speedUp and totA >= 0 then\n            return -1, -1 -- no solution\n        end\n        local distanceToMax, timeToMax = 0, 0\n\n        if a0 ~= 0 and t50 > 0 then\n\n            local k1  = math.asin(initial/C)\n            local c1  = math.pi*(a0/2+b0)\n            local c2  = a0*t50\n            local c3  = C*math.pi\n            local v = function(t)\n                local w  = (c1*t - c2*math.sin(math.pi*t/2/t50) + c3*k1)/c3\n                local tan = math.tan(w)\n                return C*tan/math.sqrt(tan*tan+1)\n            end\n            local speedchk = speedUp and function(s) return s >= final end or\n                                         function(s) return s <= final end\n            timeToMax  = 2*t50\n            if speedchk(v(timeToMax)) then\n                local lasttime = 0\n                while math.abs(timeToMax - lasttime) > 0.5 do\n                    local t = (timeToMax + lasttime)/2\n                    if speedchk(v(t)) then\n                        timeToMax = t \n                    else\n                        lasttime = t\n                    end\n                end\n            end\n            -- There is no closed form solution for distance in this case.\n            -- Numerically integrate for time t=0 to t=2*T50 (or less)\n            local lastv = initial\n            local tinc  = timeToMax/ITERATIONS\n            for step = 1, ITERATIONS do\n                local speed = v(step*tinc)\n                distanceToMax = distanceToMax + (speed+lastv)*tinc/2\n                lastv = speed\n            end\n            if timeToMax < 2*t50 then\n                return distanceToMax, timeToMax\n            end\n            initial     = lastv\n        end\n\n        local k1       = C*math.asin(initial/C)\n        local time     = (C * math.asin(final/C) - k1)/totA\n        local k2       = C2 *math.cos(k1/C)/totA\n        local distance = k2 - C2 * math.cos((totA*time + k1)/C)/totA\n        return distance+distanceToMax, time+timeToMax\n    end\n\n    function Kinematic.computeTravelTime(initial, acceleration, distance)\n        -- The low speed limit of following is: t=(sqrt(2ad+v^2)-v)/a\n        -- (from: d=vt+at^2/2)\n        if distance == 0 then return 0 end\n        if acceleration > 0 then\n            local k1       = C*math.asin(initial/C)\n            local k2       = C2*math.cos(k1/C)/acceleration\n            return (C*math.acos(acceleration*(k2 - distance)/C2) - k1)/acceleration\n        end\n        assert(initial > 0, 'Acceleration and initial speed are both zero.')\n        return distance/initial\n    end\n\n    function Kinematic.lorentz(v) return lorentz(v) end\n\n    return Kinematic\nend\n-- !DU[lib]: kepler\n\n\nfunction Keplers()\n    local vec3       = require('cpml.vec3')\n    local PlanetRef  = PlanetRef()\n    local function isString(s) return type(s)   == 'string' end\n    local function isTable(t)  return type(t)   == 'table'  end\n    local function float_eq(a,b)\n        if a == 0 then return math.abs(b) < 1e-09 end\n        if b == 0 then return math.abs(a) < 1e-09 end\n        return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon\n    end\n    Kepler = {}\n    Kepler.__index = Kepler\n\n    function Kepler:escapeAndOrbitalSpeed(altitude)\n        assert(self.body)\n        -- P = -GMm/r and KE = mv^2/2 (no lorentz factor used)\n        -- mv^2/2 = GMm/r\n        -- v^2 = 2GM/r\n        -- v = sqrt(2GM/r1)\n        local distance = altitude + self.body.radius\n        if not float_eq(distance, 0) then\n            local orbit = math.sqrt(self.body.GM/distance)\n            return math.sqrt(2)*orbit, orbit\n        end\n        return nil, nil\n    end\n\n    function Kepler:orbitalParameters(overload, velocity)\n        assert(self.body)\n        assert(isTable(overload) or isString(overload))\n        assert(isTable(velocity))\n        local pos = (isString(overload) or PlanetRef.isMapPosition(overload)) and\n                                self.body:convertToWorldCoordinates(overload) or\n                    vec3(overload)\n        local v   = vec3(velocity)\n        local r   = pos - self.body.center\n        local v2  = v:len2()\n        local d   = r:len()\n        local mu  = self.body.GM\n        local e   = ((v2 - mu/d)*r - r:dot(v)*v)/mu\n        local a   = mu/(2*mu/d - v2)\n        local ecc = e:len()\n        local dir = e:normalize()\n        local pd  = a*(1-ecc)\n        local ad  = a*(1+ecc)\n        local per = pd*dir + self.body.center\n        local apo = ecc <= 1 and -ad*dir + self.body.center or nil\n        local trm = math.sqrt(a*mu*(1-ecc*ecc))        \n        local Period = apo and 2*math.pi*math.sqrt(a^3/mu)\n        -- These are great and all, but, I need more.\n        local trueAnomaly = math.acos((e:dot(r))/(ecc*d))\n        if r:dot(v) < 0 then\n            trueAnomaly = -(trueAnomaly - 2*math.pi)\n        end        \n        -- Apparently... cos(EccentricAnomaly) = (cos(trueAnomaly) + eccentricity)/(1 + eccentricity * cos(trueAnomaly))\n        local EccentricAnomaly = math.acos((math.cos(trueAnomaly) + ecc)/(1 + ecc * math.cos(trueAnomaly)))\n        -- Then.... apparently if this is below 0, we should add 2pi to it\n        -- I think also if it's below 0, we're past the apoapsis?\n        local timeTau = EccentricAnomaly\n        if timeTau < 0 then\n            timeTau = timeTau + 2*math.pi\n        end\n        -- So... time since periapsis...\n        -- Is apparently easy if you get mean anomly.  t = M/n where n is mean motion, = 2*pi/Period\n        local MeanAnomaly = timeTau - ecc * math.sin(timeTau)\n        local TimeSincePeriapsis = 0\n        local TimeToPeriapsis = 0\n        local TimeToApoapsis = 0\n        if Period ~= nil then\n            TimeSincePeriapsis = MeanAnomaly/(2*math.pi/Period)\n            -- Mean anom is 0 at periapsis, positive before it... and positive after it.\n            -- I guess this is why I needed to use timeTau and not EccentricAnomaly here\n            \n            TimeToPeriapsis = Period - TimeSincePeriapsis\n            TimeToApoapsis = TimeToPeriapsis + Period/2\n            if trueAnomaly - math.pi > 0 then -- TBH I think something's wrong in my formulas because I needed this.\n                TimeToPeriapsis = TimeSincePeriapsis\n                TimeToApoapsis = TimeToPeriapsis + Period/2\n            end\n            if TimeToApoapsis > Period then\n                TimeToApoapsis = TimeToApoapsis - Period\n            end\n        end\n        return { periapsis       = { position           = per,\n                                     speed              = trm/pd,\n                                     circularOrbitSpeed = math.sqrt(mu/pd),\n                                     altitude           = pd - self.body.radius},\n                 apoapsis        = apo and\n                                   { position           = apo,\n                                     speed              = trm/ad,\n                                     circularOrbitSpeed = math.sqrt(mu/ad),\n                                     altitude           = ad - self.body.radius},\n                 currentVelocity = v,\n                 currentPosition = pos,\n                 eccentricity    = ecc,\n                 period          = Period,\n                 eccentricAnomaly = EccentricAnomaly,\n                 meanAnomaly = MeanAnomaly,\n                 timeToPeriapsis = TimeToPeriapsis,\n                 timeToApoapsis = TimeToApoapsis\n               }\n    end\n\n    local function new(bodyParameters)\n        local params = PlanetRef.BodyParameters(bodyParameters.planetarySystemId,\n                                                bodyParameters.bodyId,\n                                                bodyParameters.radius,\n                                                bodyParameters.center,\n                                                bodyParameters.GM)\n        return setmetatable({body = params}, Kepler)\n    end\n\n    return setmetatable(Kepler, { __call = function(_,...) return new(...) end })\nend\n-- !DU[lib]: helpers\n\n\nfunction Contains(mousex, mousey, x, y, width, height) \n    if mousex > x and mousex < (x + width) and mousey > y and mousey < (y + height) then\n        return true\n    else\n        return false\n    end\nend\n\n\nfunction round(num, numDecimalPlaces)\n    local mult = 10^(numDecimalPlaces or 0)\n    return mfloor(num * mult + 0.5) / mult\nend\n\nfunction tablelength(T)\n    local count = 0\n    for _ in pairs(T) do count = count + 1 end\n    return count\nend\n\nfunction getDistanceDisplayString(distance)\n    local su = distance > 100000\n    local result = \"\"\n    if su then\n        -- Convert to SU\n        result = round(distance/1000/200,1) .. \" SU\"\n    elseif distance < 1000 then\n        result = round(distance,1) .. \" M\"\n    else\n        -- Convert to KM\n        result = round(distance/1000,1) .. \" KM\"\n    end\n\n    return result\nend\n\nfunction getDistanceDisplayString2(distance)\n    local su = distance > 100000\n    local result = \"\"\n    if su then\n        -- Convert to SU\n        result = round(distance/1000/200,2) .. \" SU\"\n    elseif distance < 1000 then\n        result = round(distance,2) .. \" M\"\n    else\n        -- Convert to KM\n        result = round(distance/1000,2) .. \" KM\"\n    end\n\n    return result\nend\n\nfunction getSpeedDisplayString(speed) -- TODO: Allow options, for now just do kph\n    return mfloor(round(speed*3.6,0)+0.5) .. \" km/h\" -- And generally it's not accurate enough to not twitch unless we round 0\nend\n\nfunction FormatTimeString(seconds)\n    local hours = mfloor(seconds/3600)\n    local minutes = mfloor(seconds/60%60)\n    local seconds = mfloor(seconds%60)\n    if seconds < 0 or hours < 0 or minutes < 0 then\n        return \"0s\"\n    end\n    if hours > 0 then \n        return hours .. \"h \" .. minutes .. \"m \" .. seconds .. \"s\"\n    elseif minutes > 0 then\n        return minutes .. \"m \" ..seconds..\"s\"\n    else\n        return seconds..\"s\"\n    end\nend\n-- !DU[lib]: autopilot\n\n\nfunction UpdateAutopilotTarget()\n    -- So the indices are weird.  I think we need to do a pairs\n    if AutopilotTargetIndex == 0 then\n        AutopilotTargetName = \"None\"\n        AutopilotTargetPlanet = nil\n        return true\n    end\n    local count = 0\n    for k,v in pairs(Atlas()[0]) do\n        count = count + 1\n        if count == AutopilotTargetIndex then\n            AutopilotTargetName = v.name\n            AutopilotTargetPlanet = galaxyReference[0][k]\n            AutopilotTargetCoords = vec3(AutopilotTargetPlanet.center) -- Aim center until we align\n            -- Determine the end speed\n            _, AutopilotEndSpeed = kepPlanet:escapeAndOrbitalSpeed(AutopilotTargetOrbit)\n            --AutopilotEndSpeed = 0\n            --AutopilotPlanetGravity = AutopilotTargetPlanet:getGravity(AutopilotTargetPlanet.center + vec3({1,0,0}) * AutopilotTargetOrbit):len() -- Any direction, at our orbit height\n            AutopilotPlanetGravity = 0 -- This is inaccurate unless we integrate and we're not doing that.  \n            AutopilotAccelerating = false\n            AutopilotBraking = false\n            AutopilotCruising = false \n            Autoilot = false\n            AutopilotRealigned = false\n            AutopilotStatus = \"Aligning\"\n            return true\n        end\n    end\n    return false\nend\n\nfunction IncrementAutopilotTargetIndex()\n    AutopilotTargetIndex = AutopilotTargetIndex + 1\n    if AutopilotTargetIndex >  tablelength(Atlas()[0]) then \n        AutopilotTargetIndex = 0\n    end\n    UpdateAutopilotTarget()\nend\n\nfunction DecrementAutopilotTargetIndex()\n    AutopilotTargetIndex = AutopilotTargetIndex - 1\n    if AutopilotTargetIndex < 0 then \n        AutopilotTargetIndex = tablelength(Atlas()[0])\n    end\n    UpdateAutopilotTarget()\nend\n\nfunction GetAutopilotTravelTime()\n    AutopilotDistance = (AutopilotTargetPlanet.center - vec3(core.getConstructWorldPos())):len()\n    local velocity = core.getWorldVelocity() \n    local accelDistance, accelTime = Kinematic.computeDistanceAndTime(vec3(velocity):len(),\n        MaxGameVelocity, -- From currently velocity to max\n        constructMass(),\n        Nav:maxForceForward(),\n        warmup, -- T50?  Assume none, negligible for this\n        0) -- Brake thrust, none for this\n    -- accelDistance now has the amount of distance for which we will be accelerating\n    -- Then we need the distance we'd brake from full speed\n    -- Note that for some nearby moons etc, it may never reach full speed though.\n    local brakeDistance, brakeTime\n    if not TurnBurn then \n        brakeDistance, brakeTime = GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)\n    else\n        brakeDistance, brakeTime = GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)\n    end\n    local curBrakeDistance, curBrakeTime\n    if not TurnBurn then \n        curBrakeDistance, curBrakeTime = GetAutopilotBrakeDistanceAndTime(vec3(velocity):len())\n    else\n        curBrakeDistance, curBrakeTime = GetAutopilotTBBrakeDistanceAndTime(vec3(velocity):len())\n    end\n    local cruiseDistance = 0\n    local cruiseTime = 0\n    -- So, time is in seconds\n    -- If cruising or braking, use real cruise/brake values\n    if brakeDistance + accelDistance < AutopilotDistance then \n        -- Add any remaining distance\n        cruiseDistance = AutopilotDistance - (brakeDistance + accelDistance)\n        cruiseTime = Kinematic.computeTravelTime(8333.0556, 0, cruiseDistance)\n    else\n        local accelRatio = (AutopilotDistance - brakeDistance)/accelDistance\n        accelDistance = AutopilotDistance - brakeDistance -- Accel until we brake\n        accelTime = accelTime * accelRatio\n    end\n    if AutopilotBraking then\n        return curBrakeTime\n    elseif AutopilotCruising then\n        return cruiseTime + curBrakeTime\n    else -- If not cruising or braking, assume we'll get to max speed\n        return accelTime + brakeTime + cruiseTime\n    end\nend\n\nfunction GetAutopilotBrakeDistanceAndTime(speed)\n    -- If we're in atmo, just return some 0's or LastMaxBrake, whatever's bigger\n    -- So we don't do unnecessary API calls when atmo brakes don't tell us what we want\n    if atmosphere() == 0 then\n        local maxBrake = jdecode(unit.getData()).maxBrake\n        if maxBrake ~= nil then\n            LastMaxBrake = maxBrake\n            return Kinematic.computeDistanceAndTime(speed, AutopilotEndSpeed, constructMass(), 0, 0, maxBrake - (AutopilotPlanetGravity * constructMass()))\n        else\n            return Kinematic.computeDistanceAndTime(speed, AutopilotEndSpeed, constructMass(), 0, 0, LastMaxBrake - (AutopilotPlanetGravity * constructMass()))\n        end\n    else\n        if LastMaxBrake and LastMaxBrake > 0 then\n            return Kinematic.computeDistanceAndTime(speed, AutopilotEndSpeed, constructMass(), 0, 0, LastMaxBrake - (AutopilotPlanetGravity * constructMass()))\n        else\n            return 0,0\n        end\n    end\nend\n\nfunction GetAutopilotTBBrakeDistanceAndTime(speed) -- Uses thrust and a configured T50\n    local maxBrake = jdecode(unit.getData()).maxBrake\n    if maxBrake ~= nil then\n        LastMaxBrake = maxBrake\n        return Kinematic.computeDistanceAndTime(speed, AutopilotEndSpeed, constructMass(), Nav:maxForceForward(), warmup, maxBrake - (AutopilotPlanetGravity * constructMass()))\n    else\n        return Kinematic.computeDistanceAndTime(speed, AutopilotEndSpeed, constructMass(), Nav:maxForceForward(), warmup, LastMaxBrake - (AutopilotPlanetGravity * constructMass()))\n    end\nend\n-- !DU[lib]: vector-helpers\n\nfunction getMagnitudeInDirection(vector, direction)\n    --return vec3(vector):project_on(vec3(direction)):len()\n    vector = vec3(vector)\n    direction = vec3(direction):normalize()\n    local result = vector*direction -- To preserve sign, just add them I guess\n    return result.x + result.y + result.z\nend\n\nfunction getRelativeYaw(velocity) \n    velocity = vec3(velocity)\n    return math.deg(math.atan(velocity.y, velocity.x)) - 90\nend\n\nfunction AlignToWorldVector(vector, tolerance)\n    -- Sets inputs to attempt to point at the autopilot target\n    -- Meant to be called from Update or Tick repeatedly\n    if tolerance == nil then\n        tolerance = alignmentTolerance\n    end\n    vector = vec3(vector):normalize()\n    local targetVec = (vec3(core.getConstructWorldOrientationForward()) - vector)\n    local yawAmount = -getMagnitudeInDirection(targetVec, core.getConstructWorldOrientationRight()) * AutopilotStrength\n    local pitchAmount = -getMagnitudeInDirection(targetVec, core.getConstructWorldOrientationUp()) * AutopilotStrength\n\n    yawInput2 = yawInput2 - (yawAmount + (yawAmount - PreviousYawAmount) * DampingMultiplier)\n    pitchInput2 = pitchInput2 + (pitchAmount + (pitchAmount - PreviousPitchAmount) * DampingMultiplier)\n    PreviousYawAmount = yawAmount\n    PreviousPitchAmount = pitchAmount\n    -- Return true or false depending on whether or not we're aligned\n    if math.abs(yawAmount) < tolerance and math.abs(pitchAmount) < tolerance then\n        return true\n    end\n    return false\nend\n\nfunction getRelativePitch(velocity) \n    velocity = vec3(velocity)\n    local pitch = -math.deg(math.atan(velocity.y, velocity.z)) + 180\n    -- This is 0-360 where 0 is straight up\n    pitch = pitch - 90\n    -- So now 0 is straight, but we can now get angles up to 420\n    if pitch < 0 then\n       pitch = 360 + pitch \n    end \n    -- Now, if it's greater than 180, say 190, make it go to like -170\n    if pitch > 180 then\n       pitch = -180 + (pitch-180) \n    end\n    -- And it's backwards.  \n    return -pitch\nend\n-- !DU[lib]: atlas\n\n-- Planet Info - https://gitlab.com/JayleBreak/dualuniverse/-/tree/master/DUflightfiles/autoconf/custom with minor modifications\nfunction Atlas()\n    return {\n    [0] = {\n        [1]={\n                GM=6930729684,\n                bodyId=1,\n                center={x=17465536.000,y=22665536.000,z=-34464.000},\n                name='Madis',\n                planetarySystemId=0,\n                radius=44300\n            },\n        [2]={\n            GM=157470826617,\n            bodyId=2,\n            center={x=-8.000,y=-8.000,z=-126303.000},\n            name='Alioth',\n            planetarySystemId=0,\n            radius=126068\n            },\n        [3]={\n            GM=11776905000,\n            bodyId=3,\n            center={x=29165536.000,y=10865536.000,z=65536.000},\n            name='Thades',\n            planetarySystemId=0,\n            radius=49000\n            },\n        [4]={\n            GM=14893847582,\n            bodyId=4,\n            center={x=-13234464.000,y=55765536.000,z=465536.000},\n            name='Talemai',\n            planetarySystemId=0,\n            radius=57450\n            },\n        [5]={\n            GM=16951680000,\n            bodyId=5,\n            center={x=-43534464.000,y=22565536.000,z=-48934464.000},\n            name='Feli',\n            planetarySystemId=0,\n            radius=60000\n            },\n        [6]={\n            GM=10502547741,\n            bodyId=6,\n            center={x=52765536.000,y=27165538.000,z=52065535.000},\n            name='Sicari',\n            planetarySystemId=0,\n            radius=51100\n            },\n        [7]={\n            GM=13033380591,\n            bodyId=7,\n            center={x=58665538.000,y=29665535.000,z=58165535.000},\n            name='Sinnen',\n            planetarySystemId=0,\n            radius=54950\n            },\n        [8]={\n            GM=18477723600,\n            bodyId=8,\n            center={x=80865538.000,y=54665536.000,z=-934463.940},\n            name='Teoma',\n            planetarySystemId=0,\n            radius=62000\n            },\n        [9]={\n            GM=18606274330,\n            bodyId=9,\n            center={x=-94134462.000,y=12765534.000,z=-3634464.000},\n            name='Jago',\n            planetarySystemId=0,\n            radius=61590\n            },\n        [10]={\n            GM=78480000,\n            bodyId=10,\n            center={x=17448118.224,y=22966846.286,z=143078.820},\n            name='Madis Moon 1',\n            planetarySystemId=0,\n            radius=10000\n            },\n        [11]={\n            GM=237402000,\n            bodyId=11,\n            center={x=17194626.000,y=22243633.880,z=-214962.810},\n            name='Madis Moon 2',\n            planetarySystemId=0,\n            radius=11000\n            },\n        [12]={\n            GM=265046609,\n            bodyId=12,\n            center={x=17520614.000,y=22184730.000,z=-309989.990},\n            name='Madis Moon 3',\n            planetarySystemId=0,\n            radius=15005\n            },\n        [21]={\n            GM=2118960000,\n            bodyId=21,\n            center={x=457933.000,y=-1509011.000,z=115524.000},\n            name='Alioth Moon 1',\n            planetarySystemId=0,\n            radius=30000\n            },\n        [22]={\n            GM=2165833514,\n            bodyId=22,\n            center={x=-1692694.000,y=729681.000,z=-411464.000},\n            name='Alioth Moon 4',\n            planetarySystemId=0,\n            radius=30330\n            },\n        [26]={\n            GM=68234043600,\n            bodyId=26,\n            center={x=-1404835.000,y=562655.000,z=-285074.000},\n            name='Sanctuary',\n            planetarySystemId=0,\n            radius=83400\n            },\n        [30]={\n            GM=211564034,\n            bodyId=30,\n            center={x=29214402.000,y=10907080.695,z=433858.200},\n            name='Thades Moon 1',\n            planetarySystemId=0,\n            radius=14002\n            },\n        [31]={\n            GM=264870000,\n            bodyId=31,\n            center={x=29404193.000,y=10432768.000,z=19554.131},\n            name='Thades Moon 2',\n            planetarySystemId=0,\n            radius=15000\n            },\n        [40]={\n            GM=141264000,\n            bodyId=40,\n            center={x=-13503090.000,y=55594325.000,z=769838.640},\n            name='Talemai Moon 2',\n            planetarySystemId=0,\n            radius=12000\n            },\n        [41]={\n            GM=106830900,\n            bodyId=41,\n            center={x=-12800515.000,y=55700259.000,z=325207.840},\n            name='Talemai Moon 3',\n            planetarySystemId=0,\n            radius=11000\n            },\n        [42]={\n            GM=264870000,\n            bodyId=42,\n            center={x=-13058408.000,y=55781856.000,z=740177.760},\n            name='Talemai Moon 1',\n            planetarySystemId=0,\n            radius=15000\n            },\n        [50]={\n            GM=499917600,\n            bodyId=50,\n            center={x=-43902841.780,y=22261034.700,z=-48862386.000},\n            name='Feli Moon 1',\n            planetarySystemId=0,\n            radius=14000\n            },\n        [70]={\n            GM=396912600,\n            bodyId=70,\n            center={x=58969616.000,y=29797945.000,z=57969449.000},\n            name='Sinnen Moon 1',\n            planetarySystemId=0,\n            radius=17000\n            },\n        [100]={\n            GM=13975172474,\n            bodyId=100,\n            center={x=98865536.000,y=-13534464.000,z=-934461.990},\n            name='Lacobus',\n            planetarySystemId=0,\n            radius=55650\n            },\n        [101]={\n            GM=264870000,\n            bodyId=101,\n            center={x=98905288.170,y=-13950921.100,z=-647589.530},\n            name='Lacobus Moon 3',\n            planetarySystemId=0,\n            radius=15000\n            },\n        [102]={\n            GM=444981600,\n            bodyId=102,\n            center={x=99180968.000,y=-13783862.000,z=-926156.400},\n            name='Lacobus Moon 1',\n            planetarySystemId=0,\n            radius=18000\n            },\n        [103]={\n            GM=211503600,\n            bodyId=103,\n            center={x=99250052.000,y=-13629215.000,z=-1059341.400},\n            name='Lacobus Moon 2',\n            planetarySystemId=0,\n            radius=14000\n            },\n        [110]={\n            GM=9204742375,\n            bodyId=110,\n            center={x=14165536.000,y=-85634465.000,z=-934464.300},\n            name='Symeon',\n            planetarySystemId=0,\n            radius=49050\n            },\n        [120]={\n            GM=7135606629,\n            bodyId=120,\n            center={x=2865536.700,y=-99034464.000,z=-934462.020},\n            name='Ion',\n            planetarySystemId=0,\n            radius=44950\n            },\n        [121]={\n            GM=106830900,\n            bodyId=121,\n            center={x=2472916.800,y=-99133747.000,z=-1133582.800},\n            name='Ion Moon 1',\n            planetarySystemId=0,\n            radius=11000\n            },\n        [122]={\n            GM=176580000,\n            bodyId=122,\n            center={x=2995424.500,y=-99275010.000,z=-1378480.700},\n            name='Ion Moon 2',\n            planetarySystemId=0,\n            radius=15000\n            }  \n        }\n    }\nend\n\nfor k,v in pairs(Atlas()[0]) do\n    if minAtlasX == nil or v.center.x < minAtlasX then\n        minAtlasX = v.center.x\n    end\n    if maxAtlasX == nil or v.center.x > maxAtlasX then\n        maxAtlasX = v.center.x\n    end\n    if minAtlasY == nil or v.center.y < minAtlasY then\n        minAtlasY = v.center.y\n    end\n    if maxAtlasY == nil or v.center.y > maxAtlasY then\n        maxAtlasY = v.center.y\n    end\nend\nGalaxyMapHTML = \"\" -- No starting SVG tag so we can add it where we want it\n-- Figure out our scale here... \nlocal xRatio = 1.1*(maxAtlasX - minAtlasX)/1920 -- Add 10% for padding\nlocal yRatio = 1.4*(maxAtlasY - minAtlasY)/1080 -- Extra so we can get ion back in\nfor k,v in pairs(Atlas()[0]) do\n    -- Draw a circle at the scaled coordinates\n    local x = 960 + (v.center.x / xRatio)\n    local y = 540 + (v.center.y / yRatio)\n    GalaxyMapHTML = GalaxyMapHTML .. '<circle cx=\"' .. x .. '\" cy=\"' .. y .. '\" r=\"' .. (v.radius/xRatio)*30 .. '\" stroke=\"white\" stroke-width=\"3\" fill=\"blue\" />'\n    if not string.match(v.name, \"Moon\") and not string.match(v.name, \"Sanctuary\") then\n        GalaxyMapHTML = GalaxyMapHTML .. \"<text x='\" .. x .. \"' y='\" .. y + (v.radius/xRatio)*30 + 20 .. \"' font-size='28' fill=\" .. rgb .. \" text-anchor='middle' font-family='Montserrat'>\" .. v.name .. \"</text>\"\n    end\nend\n-- Draw a 'You Are Here' - face edition\nlocal pos = vec3(core.getConstructWorldPos())\nlocal x = 960 + pos.x/xRatio\nlocal y = 540 + pos.y/yRatio\nGalaxyMapHTML = GalaxyMapHTML .. '<circle cx=\"' .. x .. '\" cy=\"' .. y .. '\" r=\"5\" stroke=\"white\" stroke-width=\"3\" fill=\"red\"/>'\nGalaxyMapHTML = GalaxyMapHTML .. \"<text x='\" .. x .. \"' y='\" .. y - 50 .. \"' font-size='36' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>\"\nGalaxyMapHTML = GalaxyMapHTML .. [[</svg>]]\nMapXRatio = xRatio\nMapYRatio = yRatio\nif screen_2 then\n        screen_2.setHTML('<svg width=\"100vw\" height=\"100vh\" viewBox=\"0 0 1920 1080\">' .. GalaxyMapHTML) -- This is permanent and doesn't change\n        -- Draw a 'You Are Here' - screen edition\n        local pos = vec3(core.getConstructWorldPos())\n        local x = 960 + pos.x/xRatio\n        local y = 540 + pos.y/yRatio\n        GalaxyMapHTML = '<svg><circle cx=\"80\" cy=\"80\" r=\"5\" stroke=\"white\" stroke-width=\"3\" fill=\"red\"/>'\n        GalaxyMapHTML = GalaxyMapHTML .. \"<text x='80' y='105' font-size='18' fill=\" .. rgb .. \" text-anchor='middle' font-family='Montserrat''>You Are Here</text></svg>\"\n        YouAreHere = screen_2.addContent((x-80)/19.20, (y-80)/10.80, GalaxyMapHTML)\nend\n\nfunction PlanetRef() \n    --[[                    START OF LOCAL IMPLEMENTATION DETAILS             ]]--\n    -- Type checks\n    local function isNumber(n)  return type(n)           == 'number' end\n    local function isSNumber(n) return type(tonumber(n)) == 'number' end\n    local function isTable(t)   return type(t)           == 'table'  end\n    local function isString(s)  return type(s)           == 'string' end\n    local function isVector(v)  return isTable(v)\n                                        and isNumber(v.x and v.y and v.z) end\n    local function isMapPosition(m) return isTable(m) and isNumber(m.latitude  and\n                                                                   m.longitude and\n                                                                   m.altitude  and\n                                                                   m.bodyId    and\n                                                                   m.systemId) end\n    -- Constants\n    local deg2rad    = math.pi/180\n    local rad2deg    = 180/math.pi\n    local epsilon    = 1e-10\n    local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n    local posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' ..\n                       num ..  ',' .. num .. '}'\n    -- Utilities\n    local utils  = require('cpml.utils')\n    local vec3   = require('cpml.vec3')\n    local clamp  = utils.clamp\n    local function float_eq(a,b)\n        if a == 0 then return math.abs(b) < 1e-09 end\n        if b == 0 then return math.abs(a) < 1e-09 end\n        return math.abs(a - b) < math.max(math.abs(a),math.abs(b))*epsilon\n    end\n    local function formatNumber(n)\n        local result = string.gsub(\n                        string.reverse(stringf('%.4f',n)),\n                        '^0*%.?','')\n        return result == '' and '0' or string.reverse(result)\n    end\n    local function formatValue(obj)\n        if isVector(obj) then\n            return stringf('{x=%.3f,y=%.3f,z=%.3f}', obj.x, obj.y, obj.z)\n        end\n        if isTable(obj) and not getmetatable(obj) then\n            local list = {}\n            local nxt  = next(obj)\n            if type(nxt) == 'nil' or nxt == 1 then -- assume this is an array\n                list = obj\n            else\n                for k,v in pairs(obj) do\n                    local value = formatValue(v)\n                    if type(k) == 'number' then\n                        table.insert(list, stringf('[%s]=%s', k, value))\n                    else\n                        table.insert(list, stringf('%s=%s',   k, value))\n                    end\n                end\n            end\n            return stringf('{%s}', table.concat(list, ','))\n        end\n        if isString(obj) then\n            return stringf(\"'%s'\", obj:gsub(\"'\",[[\\']]))\n        end\n        return tostring(obj)\n    end\n    -- CLASSES\n    -- BodyParameters: Attributes of planetary bodies (planets and moons)\n    local BodyParameters = {}\n    BodyParameters.__index = BodyParameters\n    BodyParameters.__tostring =\n        function(obj, indent)\n            local sep = indent or ''\n            local keys = {}\n            for k in pairs(obj) do table.insert(keys, k) end\n            table.sort(keys)\n            local list = {}\n            for _, k in ipairs(keys) do\n                local value = formatValue(obj[k])\n                if type(k) == 'number' then\n                    table.insert(list, stringf('[%s]=%s', k, value))\n                else\n                    table.insert(list, stringf('%s=%s', k, value))\n                end\n            end\n            if indent then\n                return stringf('%s%s',\n                                     indent,\n                                     table.concat(list, ',\\n' .. indent))\n            end\n            return stringf('{%s}', table.concat(list, ','))\n        end\n    BodyParameters.__eq = function(lhs, rhs)\n            return lhs.planetarySystemId == rhs.planetarySystemId and\n                   lhs.bodyId            == rhs.bodyId            and\n                   float_eq(lhs.radius, rhs.radius)               and\n                   float_eq(lhs.center.x, rhs.center.x)           and\n                   float_eq(lhs.center.y, rhs.center.y)           and\n                   float_eq(lhs.center.z, rhs.center.z)           and\n                   float_eq(lhs.GM, rhs.GM)\n        end\n    local function mkBodyParameters(systemId, bodyId, radius, worldCoordinates, GM)\n        -- 'worldCoordinates' can be either table or vec3\n        assert(isSNumber(systemId),\n               'Argument 1 (planetarySystemId) must be a number:' .. type(systemId))\n        assert(isSNumber(bodyId),\n               'Argument 2 (bodyId) must be a number:' .. type(bodyId))\n        assert(isSNumber(radius),\n               'Argument 3 (radius) must be a number:' .. type(radius))\n        assert(isTable(worldCoordinates),\n               'Argument 4 (worldCoordinates) must be a array or vec3.' ..\n               type(worldCoordinates))\n        assert(isSNumber(GM),\n               'Argument 5 (GM) must be a number:' .. type(GM))\n        return setmetatable({planetarySystemId = tonumber(systemId),\n                             bodyId            = tonumber(bodyId),\n                             radius            = tonumber(radius),\n                             center            = vec3(worldCoordinates),\n                             GM                = tonumber(GM) }, BodyParameters)\n    end\n    -- MapPosition: Geographical coordinates of a point on a planetary body.\n    local MapPosition = {}\n    MapPosition.__index = MapPosition\n    MapPosition.__tostring = function(p)\n            return stringf('::pos{%d,%d,%s,%s,%s}',\n                                 p.systemId,\n                                 p.bodyId,\n                                 formatNumber(p.latitude*rad2deg),\n                                 formatNumber(p.longitude*rad2deg),\n                                 formatNumber(p.altitude))\n        end\n    MapPosition.__eq       = function(lhs, rhs)\n            return lhs.bodyId   == rhs.bodyId              and\n                   lhs.systemId == rhs.systemId            and\n                   float_eq(lhs.latitude,   rhs.latitude)  and\n                   float_eq(lhs.altitude,   rhs.altitude)  and\n                   (float_eq(lhs.longitude, rhs.longitude) or\n                    float_eq(lhs.latitude, math.pi/2)      or\n                    float_eq(lhs.latitude, -math.pi/2))\n        end\n    -- latitude and longitude are in degrees while altitude is in meters\n    local function mkMapPosition(overload, bodyId, latitude, longitude, altitude)\n        local systemId = overload -- Id or '::pos{...}' string\n        if isString(overload) and not longitude and not altitude and\n                                  not bodyId    and not latitude then\n            systemId, bodyId, latitude, longitude, altitude =\n                                                string.match(overload, posPattern)\n            assert(systemId, 'Argument 1 (position string) is malformed.')\n        else\n            assert(isSNumber(systemId),\n                   'Argument 1 (systemId) must be a number:' .. type(systemId))\n            assert(isSNumber(bodyId),\n                   'Argument 2 (bodyId) must be a number:' .. type(bodyId))\n            assert(isSNumber(latitude),\n                   'Argument 3 (latitude) must be in degrees:' .. type(latitude))\n            assert(isSNumber(longitude),\n                   'Argument 4 (longitude) must be in degrees:' .. type(longitude))\n            assert(isSNumber(altitude),\n                   'Argument 5 (altitude) must be in meters:' .. type(altitude))\n        end\n        systemId  = tonumber(systemId)\n        bodyId    = tonumber(bodyId)\n        latitude  = tonumber(latitude)\n        longitude = tonumber(longitude)\n        altitude  = tonumber(altitude)\n        if bodyId == 0 then -- this is a hack to represent points in space\n            return setmetatable({latitude  = latitude,\n                                 longitude = longitude,\n                                 altitude  = altitude,\n                                 bodyId    = bodyId,\n                                 systemId  = systemId}, MapPosition)\n        end\n        return setmetatable({latitude  = deg2rad*clamp(latitude, -90, 90),\n                             longitude = deg2rad*(longitude % 360),\n                             altitude  = altitude,\n                             bodyId    = bodyId,\n                             systemId  = systemId}, MapPosition)\n    end\n    -- PlanetarySystem - map body IDs to BodyParameters\n    local PlanetarySystem = {}\n    PlanetarySystem.__index = PlanetarySystem\n    PlanetarySystem.__tostring =\n        function (obj, indent)\n            local sep = indent and (indent .. '  ' )\n            local bdylist = {}\n            local keys = {}\n            for k in pairs(obj) do table.insert(keys, k) end\n            table.sort(keys)\n            for _, bi in ipairs(keys) do\n                bdy = obj[bi]\n                local bdys = BodyParameters.__tostring(bdy, sep)\n                if indent then\n                    table.insert(bdylist,\n                                 stringf('[%s]={\\n%s\\n%s}',\n                                               bi, bdys, indent))\n                else\n                    table.insert(bdylist, stringf('  [%s]=%s', bi, bdys))\n                end\n            end\n            if indent then\n                return stringf('\\n%s%s%s',\n                                     indent,\n                                     table.concat(bdylist, ',\\n' .. indent),\n                                     indent)\n            end\n            return stringf('{\\n%s\\n}', table.concat(bdylist, ',\\n'))\n        end\n    local function mkPlanetarySystem(referenceTable)\n        local atlas = {}\n        local pid\n        for _, v in pairs(referenceTable) do\n            local id = v.planetarySystemId\n            if type(id) ~= 'number' then\n                error('Invalid planetary system ID: ' .. tostring(id))\n            elseif pid and id ~= pid then\n                error('Mismatch planetary system IDs: ' .. id .. ' and '\n                      .. pid)\n            end\n            local bid = v.bodyId\n            if type(bid) ~= 'number' then\n                error('Invalid body ID: ' .. tostring(bid))\n            elseif atlas[bid] then\n                error('Duplicate body ID: ' .. tostring(bid))\n            end\n            setmetatable(v.center, getmetatable(vec3.unit_x))\n            atlas[bid] = setmetatable(v, BodyParameters)\n            pid = id\n        end\n        return setmetatable(atlas, PlanetarySystem)\n    end\n    -- PlanetaryReference - map planetary system ID to PlanetarySystem\n    PlanetaryReference = {}\n    local function mkPlanetaryReference(referenceTable)\n        return setmetatable({ galaxyAtlas = referenceTable or {} },\n                              PlanetaryReference)\n    end\n    PlanetaryReference.__index        = \n        function(t,i)\n            if type(i) == 'number' then\n                local system = t.galaxyAtlas[i]\n                return mkPlanetarySystem(system)\n            end\n            return rawget(PlanetaryReference, i)\n        end\n    PlanetaryReference.__pairs        =\n        function(obj)\n            return  function(t, k)\n                        local nk, nv = next(t, k)\n                        return nk, nv and mkPlanetarySystem(nv)\n                    end, obj.galaxyAtlas, nil\n        end\n    PlanetaryReference.__tostring     =\n        function (obj)\n            local pslist = {}\n            for _,ps in pairs(obj or {}) do\n                local psi = ps:getPlanetarySystemId()\n                local pss = PlanetarySystem.__tostring(ps, '    ')\n                table.insert(pslist,\n                             stringf('  [%s]={%s\\n  }', psi, pss))\n            end\n            return stringf('{\\n%s\\n}\\n', table.concat(pslist,',\\n'))\n        end\n    PlanetaryReference.BodyParameters = mkBodyParameters\n    PlanetaryReference.MapPosition    = mkMapPosition\n    PlanetaryReference.PlanetarySystem = mkPlanetarySystem\n    function PlanetaryReference.createBodyParameters(planetarySystemId,\n                                                     bodyId,\n                                                     surfaceArea,\n                                                     aPosition,\n                                                     verticalAtPosition,\n                                                     altitudeAtPosition,\n                                                     gravityAtPosition)\n        assert(isSNumber(planetarySystemId),\n               'Argument 1 (planetarySystemId) must be a number:' ..\n               type(planetarySystemId))\n        assert(isSNumber(bodyId),\n               'Argument 2 (bodyId) must be a number:' .. type(bodyId))\n        assert(isSNumber(surfaceArea),\n               'Argument 3 (surfaceArea) must be a number:' .. type(surfaceArea))\n        assert(isTable(aPosition),\n               'Argument 4 (aPosition) must be an array or vec3:' ..\n               type(aPosition))\n        assert(isTable(verticalAtPosition),\n               'Argument 5 (verticalAtPosition) must be an array or vec3:' ..\n               type(verticalAtPosition))\n        assert(isSNumber(altitudeAtPosition),\n               'Argument 6 (altitude) must be in meters:' ..\n               type(altitudeAtPosition))\n        assert(isSNumber(gravityAtPosition),\n               'Argument 7 (gravityAtPosition) must be number:' ..\n               type(gravityAtPosition))\n        local radius   = math.sqrt(surfaceArea/4/math.pi)\n        local distance = radius + altitudeAtPosition\n        local center   = vec3(aPosition) + distance*vec3(verticalAtPosition)\n        local GM       = gravityAtPosition * distance * distance\n        return mkBodyParameters(planetarySystemId, bodyId, radius, center, GM)\nend\n\nPlanetaryReference.isMapPosition  = isMapPosition\n\nfunction PlanetaryReference:getPlanetarySystem(overload)\n    --if galaxyAtlas then\n        local planetarySystemId = overload\n        if isMapPosition(overload) then\n            planetarySystemId = overload.systemId\n        end\n        if type(planetarySystemId) == 'number' then\n            local system = self.galaxyAtlas[i]\n            if system then\n                if getmetatable(nv) ~= PlanetarySystem then\n                    system = mkPlanetarySystem(system)\n                end\n                return system\n            end\n        end\n    --end\n    --return nil\nend\n\nfunction PlanetarySystem:castIntersections(origin,\n                                           direction,\n                                           sizeCalculator,\n                                           bodyIds)\n    local sizeCalculator = sizeCalculator or \n                            function (body) return 1.05*body.radius end\n    local candidates = {}\n    if bodyIds then\n        for _,i in ipairs(bodyIds) do candidates[i] = self[i] end\n    else\n        bodyIds = {}\n        for k,body in pairs(self) do\n            table.insert(bodyIds, k)\n            candidates[k] = body\n        end\n    end\n    local function compare(b1,b2)\n        local v1 = candidates[b1].center - origin\n        local v2 = candidates[b2].center - origin\n        return v1:len() < v2:len()\n    end\n    table.sort(bodyIds, compare)\n    local dir = direction:normalize()\n    for i, id in ipairs(bodyIds) do\n        local body   = candidates[id]\n        local c_oV3  = body.center - origin\n        local radius = sizeCalculator(body)\n        local dot    = c_oV3:dot(dir)\n        local desc   = dot^2 - (c_oV3:len2() - radius^2)\n        if desc >= 0 then\n            local root     = math.sqrt(desc)\n            local farSide  = dot + root\n            local nearSide = dot - root\n            if nearSide > 0 then\n                return body, farSide, nearSide\n            elseif farSide > 0 then\n                return body, farSide, nil\n            end\n        end\n    end\n    return nil, nil, nil\nend\n\nfunction PlanetarySystem:closestBody(coordinates)\n    assert(type(coordinates) == 'table', 'Invalid coordinates.')\n    local minDistance2, body\n    local coord = vec3(coordinates)\n    for _,params in pairs(self) do\n        local distance2 = (params.center - coord):len2()\n        if not body or distance2 < minDistance2 then\n            body         = params\n            minDistance2 = distance2\n        end\n    end\n    return body\nend\n\nfunction PlanetarySystem:convertToBodyIdAndWorldCoordinates(overload)\n    local mapPosition = overload\n    if isString(overload) then\n        mapPosition = mkMapPosition(overload)\n    end\n    if mapPosition.bodyId == 0 then\n        return 0, vec3(mapPosition.latitude,\n                       mapPosition.longitude,\n                       mapPosition.altitude)\n    end\n    local params = self:getBodyParameters(mapPosition)\n    if params then\n        return mapPosition.bodyId,\n               params:convertToWorldCoordinates(mapPosition)\n    end\nend\n\nfunction PlanetarySystem:getBodyParameters(overload)\n    local bodyId = overload\n    if isMapPosition(overload) then\n        bodyId = overload.bodyId\n    end\n    assert(isSNumber(bodyId),\n               'Argument 1 (bodyId) must be a number:' .. type(bodyId))\n    return self[bodyId]\nend\n\nfunction PlanetarySystem:getPlanetarySystemId()\n    local k, v = next(self)\n    return v and v.planetarySystemId\nend\n\nfunction BodyParameters:convertToMapPosition(worldCoordinates)\n    assert(isTable(worldCoordinates),\n           'Argument 1 (worldCoordinates) must be an array or vec3:' ..\n           type(worldCoordinates))\n    local worldVec  = vec3(worldCoordinates) \n    if self.bodyId == 0 then\n        return setmetatable({latitude  = worldVec.x,\n                             longitude = worldVec.y,\n                             altitude  = worldVec.z,\n                             bodyId    = 0,\n                             systemId  = self.planetarySystemId}, MapPosition)\n    end\n    local coords    = worldVec - self.center\n    local distance  = coords:len()\n    local altitude  = distance - self.radius\n    local latitude  = 0\n    local longitude = 0\n    if not float_eq(distance, 0) then\n        local phi = math.atan(coords.y, coords.x)\n        longitude = phi >= 0 and phi or (2*math.pi + phi)\n        latitude  = math.pi/2 - math.acos(coords.z/distance)\n    end\n    return setmetatable({latitude  = latitude,\n                         longitude = longitude,\n                         altitude  = altitude,\n                         bodyId    = self.bodyId,\n                         systemId  = self.planetarySystemId}, MapPosition)\nend\n\nfunction BodyParameters:convertToWorldCoordinates(overload)\n    local mapPosition = isString(overload) and\n                                           mkMapPosition(overload) or overload\n    if mapPosition.bodyId == 0 then -- support deep space map position\n        return vec3(mapPosition.latitude,\n                    mapPosition.longitude,\n                    mapPosition.altitude)\n    end\n    assert(isMapPosition(mapPosition),\n           'Argument 1 (mapPosition) is not an instance of \"MapPosition\".')\n    assert(mapPosition.systemId == self.planetarySystemId,\n           'Argument 1 (mapPosition) has a different planetary system ID.')\n    assert(mapPosition.bodyId == self.bodyId,\n           'Argument 1 (mapPosition) has a different planetary body ID.')\n    local xproj = math.cos(mapPosition.latitude)\n    return self.center + (self.radius + mapPosition.altitude) *\n           vec3(xproj*math.cos(mapPosition.longitude),\n                xproj*math.sin(mapPosition.longitude),\n                math.sin(mapPosition.latitude))\nend\n\nfunction BodyParameters:getAltitude(worldCoordinates)\n    return (vec3(worldCoordinates) - self.center):len() - self.radius\nend\n\nfunction BodyParameters:getDistance(worldCoordinates)\n    return (vec3(worldCoordinates) - self.center):len()\nend\n\nfunction BodyParameters:getGravity(worldCoordinates)\n    local radial = self.center - vec3(worldCoordinates) -- directed towards body\n    local len2   = radial:len2()\n    return (self.GM/len2) * radial/math.sqrt(len2)\nend\n-- end of module\nreturn setmetatable(PlanetaryReference,\n                    { __call = function(_,...)\n                                    return mkPlanetaryReference(...)\n                               end })\nend\n\nPlanetaryReference = PlanetRef()\ngalaxyReference = PlanetaryReference(Atlas())\nKinematic = Kinematics()\nKep = Keplers()\n-- !DU[lib]: widgets\n\n14.widgets.lua-- !DU[lib]: hud\n\nfunction DrawDeadZone(newContent)\n    if system.isViewLocked() == 0 then\n        newContent[#newContent + 1] = stringf(\"<circle cx='50%%' cy='50%%' r='%d' stroke=rgb(%d,%d,%d) stroke-width='2' fill='none' />\",DeadZone, mfloor(PrimaryR*0.3), mfloor(PrimaryG*0.3), mfloor(PrimaryB*0.3))\n    else\n        newContent[#newContent + 1] = stringf(\"<circle cx='50%%' cy='50%%' r='%d' stroke=rgb(%d,%d,%d) stroke-width='2' fill='none' />\",DeadZone, mfloor(PrimaryR*0.8), mfloor(PrimaryG*0.8), mfloor(PrimaryB*0.8))\n    end\nend\n\n-- !DU[lib]: hud-helpers\n\n20.hud-helpers.lua-- !DU[lib]: functions\n\nfunction ToggleRadarPanel()\n    if radarPanelID ~= nil and peris == 0 then\n        system.destroyWidgetPanel(radarPanelID)\n        radarPanelID = nil\n        if perisPanelID ~= nil then\n            system.destroyWidgetPanel(perisPanelID)\n            perisPanelID = nil\n        end\n    else\n        -- If radar is installed but no weapon, don't show periscope\n        if peris == 1 then\n            system.destroyWidgetPanel(radarPanelID)\n            radarPanelID = nil\n            _autoconf.displayCategoryPanel(radar, radar_size, \"Periscope\", \"periscope\")\n            perisPanelID =  _autoconf.panels[_autoconf.panels_size]\n        end\n        placeRadar = true\n        if radarPanelID == nil and placeRadar then\n            _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n            radarPanelID =  _autoconf.panels[_autoconf.panels_size]\n            placeRadar = false\n        end\n        peris = 0\n    end\nend\n\nfunction ToggleWidgets()\n    if UnitHidden then\n        unit.show()\n        core.show()\n        if atmofueltank_size > 0 then\n            _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, \"Atmo Fuel\", \"fuel_container\")\n            fuelPanelID =  _autoconf.panels[_autoconf.panels_size]\n        end\n        if spacefueltank_size > 0 then\n            _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, \"Space Fuel\", \"fuel_container\")\n            spacefuelPanelID =  _autoconf.panels[_autoconf.panels_size]\n        end\n        if rocketfueltank_size > 0 then\n            _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, \"Rocket Fuel\", \"fuel_container\")\n            rocketfuelPanelID =  _autoconf.panels[_autoconf.panels_size]\n        end\n        UnitHidden = false\n    else\n        unit.hide()\n        core.hide()\n        if fuelPanelID ~= nil then\n            system.destroyWidgetPanel(fuelPanelID)\n            fuelPanelID = nil\n        end\n        if spacefuelPanelID ~= nil then\n            system.destroyWidgetPanel(spacefuelPanelID)\n            spacefuelPanelID = nil\n        end\n        if rocketfuelPanelID ~= nil then\n            system.destroyWidgetPanel(rocketfuelPanelID)\n            rocketfuelPanelID = nil\n        end\n\n        UnitHidden = true\n    end\nend\n\n-- Interplanetary helper\nfunction ShowInterplanetaryPanel()\n    if panelInterplanetary == nil then\n        panelInterplanetary = system.createWidgetPanel(\"Interplanetary Helper\")\n        interplanetaryHeader = system.createWidget(panelInterplanetary, \"value\")\n        interplanetaryHeaderText = system.createData('{\"label\": \"Target Planet\", \"value\": \"N/A\", \"unit\":\"\"}')\n        system.addDataToWidget(interplanetaryHeaderText, interplanetaryHeader)\n        widgetDistance = system.createWidget(panelInterplanetary, \"value\")\n        widgetDistanceText = system.createData('{\"label\": \"Distance\", \"value\": \"N/A\", \"unit\":\"\"}')\n        system.addDataToWidget(widgetDistanceText, widgetDistance)\n        widgetTravelTime = system.createWidget(panelInterplanetary, \"value\")\n        widgetTravelTimeText = system.createData('{\"label\": \"Travel Time\", \"value\": \"N/A\", \"unit\":\"\"}')\n        system.addDataToWidget(widgetTravelTimeText, widgetTravelTime)\n        widgetCurBrakeDistance = system.createWidget(panelInterplanetary, \"value\")\n        widgetCurBrakeDistanceText = system.createData('{\"label\": \"Cur Brake Distance\", \"value\": \"N/A\", \"unit\":\"\"}')\n        if not InAtmo then system.addDataToWidget(widgetCurBrakeDistanceText, widgetCurBrakeDistance) end\n        widgetCurBrakeTime = system.createWidget(panelInterplanetary, \"value\")\n        widgetCurBrakeTimeText = system.createData('{\"label\": \"Cur Brake Time\", \"value\": \"N/A\", \"unit\":\"\"}')\n        if not InAtmo then system.addDataToWidget(widgetCurBrakeTimeText, widgetCurBrakeTime) end\n        widgetMaxBrakeDistance = system.createWidget(panelInterplanetary, \"value\")\n        widgetMaxBrakeDistanceText = system.createData('{\"label\": \"Max Brake Distance\", \"value\": \"N/A\", \"unit\":\"\"}')\n        if not InAtmo then system.addDataToWidget(widgetMaxBrakeDistanceText, widgetMaxBrakeDistance) end\n        widgetMaxBrakeTime = system.createWidget(panelInterplanetary, \"value\")\n        widgetMaxBrakeTimeText = system.createData('{\"label\": \"Max Brake Time\", \"value\": \"N/A\", \"unit\":\"\"}')\n        if not InAtmo then system.addDataToWidget(widgetMaxBrakeTimeText, widgetMaxBrakeTime) end\n        widgetTrajectoryAltitude = system.createWidget(panelInterplanetary, \"value\")\n        widgetTrajectoryAltitudeText = system.createData('{\"label\": \"Projected Altitude\", \"value\": \"N/A\", \"unit\":\"\"}')\n        if not InAtmo then system.addDataToWidget(widgetTrajectoryAltitudeText, widgetTrajectoryAltitude) end\n    end\nend\n\nfunction toggleFollowMode()\n    if Nav.control.isRemoteControlled() == 1 then\n        FollowMode = not FollowMode\n        if FollowMode then \n            Autopilot = false\n            RetrogradeIsOn = false\n            ProgradeIsOn = false\n            AutoBrake = false\n            if not AltitudeHold then\n                OldAutoRoll = autoRoll\n            end\n            AltitudeHold = false\n            AutoLanding = false\n            AutoTakeoff = false\n            OldGearExtended = gearExtended\n            gearExtended = false\n            Nav.control.retractLandingGears()\n            Nav.axisCommandManager:setTargetGroundAltitude(500) -- Hard-set this for auto-follow\n        else\n            BrakeIsOn = true\n            autoRoll = OldAutoRoll\n            gearExtended = OldGearExtended\n            if gearExtended then\n                Nav.control.extendLandingGears()\n                Nav.axisCommandManager:setTargetGroundAltitude(0)\n            end\n        end\n    end\nend\n\nfunction AutopilotToggle()\n    -- Toggle Autopilot, as long as the target isn't None\n    if AutopilotTargetName ~= \"None\" and not Autopilot then\n        Autopilot = true\n        RetrogradeIsOn = false\n        ProgradeIsOn = false\n        AutopilotButtonHovered = false\n        AutopilotRealigned = false\n        FollowMode = false\n        AltitudeHold = false\n        AutoLanding = false\n        AutoTakeoff = false\n    else\n        Autopilot = false\n        AutopilotButtonHovered = false\n        AutopilotRealigned = false\n    end\nend\n\nfunction checkDamage()\n    local percentDam = 0\n    local color = 0\n    local colorMod = [[]]\n    local maxShipHP = eleTotalMaxHp\n    local curShipHP = 0\n    local voxelDam = 0\n    local damagedElements = 0\n    local disabledElements = 0\n    for k in pairs(elementsID) do\n        local hp = 0\n        local mhp = 0\n        mhp = eleMaxHp(elementsID[k])\n        hp = eleHp(elementsID[k])\n        curShipHP = curShipHP + hp\n        if (hp == 0) then\n            disabledElements = disabledElements +1\n        elseif (hp < mhp) then \n            damagedElements = damagedElements +1 \n        end\n    end\n    percentDam = mfloor((curShipHP * 100 / maxShipHP))\n    voxelDam = math.ceil( 100*(constructMass() - updateMass()) / honeyCombMass)\n    colorMod = percentDam*2.55\n    color = [[rgb(]] .. 255-colorMod .. \",\" .. colorMod .. \",\" .. 0 .. [[)]]\n    if voxelDam < 100 then \n        damageMessage = damageMessage.. [[\n            <g class=\"text\"><g font-size=18>\n                <text x=50% y=\"1015\" text-anchor=\"middle\" style=\"fill:]] .. color .. [[\">Structural Integrity: ]]..voxelDam..[[%</text>]]\n    end\n    if percentDam < 100 then\n        damageMessage = damageMessage.. [[\n            <g class=\"text\"><g font-size=18>\n                <text x=50% y=\"1035\" text-anchor=\"middle\" style=\"fill:]] .. color .. [[\">Elemental Integrity: ]]..percentDam..[[%</text>]]\n        if (disabledElements > 0) then \n            damageMessage = damageMessage..[[<text x=50% y=\"1055\" text-anchor=\"middle\" style=\"fill:red\">Disabled Modules: ]]..disabledElements..[[ Damaged Modules: ]]..damagedElements..[[</text></g></g>]]\n        elseif damagedElements > 0 then\n            damageMessage = damageMessage..[[<text x=50% y=\"1055\" text-anchor=\"middle\" style=\"fill:]] .. color .. [[\">Damaged Modules: ]]..damagedElements..[[</text>\n            </g></g>]]\n        end\n    end\nend\nfunction DrawCursorLine(newContent)\n    local strokeColor = mfloor(utils.clamp((distance/(ResolutionWidth/4))*255,0,255))\n    newContent[#newContent + 1] = stringf(\"<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />\",simulatedX, simulatedY, mfloor(PrimaryR+0.5) + strokeColor, mfloor(PrimaryG+0.5)-strokeColor, mfloor(PrimaryB+0.5)-strokeColor)\nend\n\nfunction ToggleAutoBrake()\n    if AutopilotTargetPlanetName ~= \"None\" and brakeInput == 0 and not AutoBrake then\n        AutoBrake = true\n        Autopilot = false\n        ProgradeIsOn = false\n        RetrogradeIsOn = false\n        FollowMode = false\n        AltitudeHold = false\n        AutoLanding = false\n        AutoTakeoff = false\n    else\n        AutoBrake = false\n    end\nend\n\nfunction getPitch(gravityDirection, forward, right)\n    local horizontalForward = gravityDirection:cross(right):normalize_inplace() -- Cross forward?\n    local pitch = math.acos(utils.clamp(horizontalForward:dot(-forward), -1, 1)) * constants.rad2deg -- acos?\n    if horizontalForward:cross(-forward):dot(right) < 0 then pitch = -pitch end -- Cross right dot forward?\n    return pitch\nend\n\nfunction saveVariables()\n    if not dbHud then\n        msgText = \"No Databank Found, unable to save. You must have a Databank attached to ship prior to running the HUD autoconfigure\" \n    elseif valuesAreSet then\n        if doubleCheck then\n            -- If any values are set, wipe them all\n            for k,v in pairs(SaveableVariables) do\n                dbHud.setStringValue(v,jencode(nil))\n            end\n            -- Including the auto vars\n            ResetAutoVars = true\n            for k,v in pairs(AutoVariables) do\n                dbHud.setStringValue(v, jencode(nil))\n            end\n            msgText = \"Databank wiped. Get out of the seat, set the savable variables, then re-enter seat and hit ALT-7 again\"\n            doubleCheck = false\n            valuesAreSet = false\n        else\n            msgText = \"Press ALT-7 again to confirm wipe\"\n            doubleCheck = true\n        end\n    else\n        for k,v in pairs(SaveableVariables) do\n            dbHud.setStringValue(v,jencode(_G[v]))\n        end\n        msgText = \"Saved Variables to Datacore\"\n        ResetAutoVars = false\n        valuesAreSet = true\n    end\nend\n\nfunction ProgradeToggle()\n    -- Toggle Progrades\n    ProgradeIsOn = not ProgradeIsOn\n    RetrogradeIsOn = false -- Don't let both be on\n    Autopilot = false\n    AltitudeHold = false\n    AutoBrake = false\n    FollowMode = false\n    AutoLanding = false\n    AutoTakeoff = false\n    ProgradeButtonHovered = false\n    local Progradestring = \"Off\"\n    if ProgradeIsOn then\n        Progradestring = \"On\"\n    end\nend\n\nfunction RetrogradeToggle()\n    -- Toggle Retrogrades\n    RetrogradeIsOn = not RetrogradeIsOn\n    ProgradeIsOn = false -- Don't let both be on\n    Autopilot = false\n    AltitudeHold = false\n    AutoBrake = false\n    FollowMode = false\n    AutoLanding = false\n    AutoTakeoff = false\n    RetrogradeButtonHovered = false\n    local Retrogradestring = \"Off\"\n    if RetrogradeIsOn then\n        Retrogradestring = \"On\"\n    end\nend\n\nfunction BrakeToggle()\n    -- Toggle brakes\n    BrakeIsOn = not BrakeIsOn\n    BrakeButtonHovered = false\n    if BrakeIsOn and not AutoTakeoff then\n        -- If they turn on brakes, disable a few things\n        AltitudeHold = false\n        AutoTakeoff = false\n        AutoLanding = false -- If they tap it, we abort, that's the way it goes.\n        -- We won't abort interplanetary because that would fuck everyone.\n        ProgradeIsOn = false -- No reason to brake while facing prograde, but retrograde yes.\n    elseif not AutoTakeoff then\n        AutoLanding = false -- If they disable during an autoland that's braking, still need to stop autoland\n        AltitudeHold = false -- And stop alt hold\n    end\nend\n\nfunction CheckButtons()\n    if BrakeButtonHovered then\n        brakeToggle = not brakeToggle\n    end\n    if ProgradeButtonHovered then\n        ProgradeToggle()\n    end\n    if RetrogradeButtonHovered then\n        RetrogradeToggle()\n    end\n\n    if AutopilotButtonHovered then\n        AutopilotToggle()\n    end\n    if TurnBurnButtonHovered then\n        ToggleTurnBurn()\n    end\n    if LandingButtonHovered then\n        if AutoLanding then\n            AutoLanding = false\n            -- Don't disable alt hold for auto land\n        else\n            if not AltitudeHold then\n                ToggleAltitudeHold()\n            end\n            AutoTakeoff = false\n            AutoLanding = true\n            Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 0)\n        end\n    end\n    if TakeoffButtonHovered then\n        if AutoTakeoff then\n            -- Turn it off, and also AltitudeHold cuz it's weird if you cancel and that's still going \n            AutoTakeoff = false\n            if AltitudeHold then\n                ToggleAltitudeHold()\n            end\n        else\n            if not AltitudeHold then\n                ToggleAltitudeHold()\n            end\n            AutoTakeoff = true\n            HoldAltitude = core_altitude + AutoTakeoffAltitude\n            gearExtended = false\n            Nav.control.retractLandingGears()\n            Nav.axisCommandManager:setTargetGroundAltitude(500) -- Hard set this for takeoff, you wouldn't use takeoff from a hangar\n            BrakeIsOn = true\n        end\n    end\n    if AltitudeHoldButtonHovered then\n        ToggleAltitudeHold()\n    end\n    if FollowModeButtonHovered then\n        toggleFollowMode()\n    end\n    BrakeButtonHovered = false         \n    RetrogradeButtonHovered = false    \n    ProgradeButtonHovered = false\n    AutopilotButtonHovered = false\n    TurnBurnButtonHovered = false\n    FollowModeButtonHovered = false\n    AltitudeHoldButtonHovered = false\n    LandingButtonHovered = false\n    TakeoffButtonHovered = false -- After checking, clear our flags.\nend\n\nfunction SetButtonContains()\n    BrakeButtonHovered = Contains(simulatedX + ResolutionWidth/2, simulatedY + ResolutionHeight/2, ButtonBrakeX, ButtonBrakeY, ButtonBrakeWidth, ButtonBrakeHeight)\n    ProgradeButtonHovered = Contains(simulatedX + ResolutionWidth/2, simulatedY + ResolutionHeight/2, ButtonProgradeX, ButtonProgradeY, ButtonProgradeWidth, ButtonProgradeHeight)\n    RetrogradeButtonHovered = Contains(simulatedX + ResolutionWidth/2, simulatedY + ResolutionHeight/2, ButtonRetrogradeX, ButtonRetrogradeY, ButtonRetrogradeWidth, ButtonRetrogradeHeight)\n    AutopilotButtonHovered = Contains(simulatedX + ResolutionWidth/2, simulatedY + ResolutionHeight/2, ButtonAutopilotX, ButtonAutopilotY, ButtonAutopilotWidth, ButtonAutopilotHeight)\n    AltitudeHoldButtonHovered = Contains(simulatedX + ResolutionWidth/2, simulatedY + ResolutionHeight/2, ButtonAltitudeHoldX, ButtonAltitudeHoldY, ButtonAltitudeHoldWidth, ButtonAltitudeHoldHeight)\n    TakeoffButtonHovered = Contains(simulatedX + ResolutionWidth/2, simulatedY + ResolutionHeight/2, ButtonTakeoffX, ButtonTakeoffY, ButtonTakeoffWidth, ButtonTakeoffHeight)\n    LandingButtonHovered = Contains(simulatedX + ResolutionWidth/2, simulatedY + ResolutionHeight/2, ButtonLandingX, ButtonLandingY, ButtonLandingWidth, ButtonLandingHeight)\n    TurnBurnButtonHovered = Contains(simulatedX + ResolutionWidth/2, simulatedY + ResolutionHeight/2, ButtonTurnBurnX, ButtonTurnBurnY, ButtonTurnBurnWidth, ButtonTurnBurnHeight)\n    FollowModeButtonHovered = Contains(simulatedX + ResolutionWidth/2, simulatedY + ResolutionHeight/2, ButtonFollowModeX, ButtonFollowModeY, ButtonFollowModeWidth, ButtonFollowModeHeight)\n    -- And... Check the map if it's up\n    -- For now that's RC only\n    if Nav.control.isRemoteControlled() == 1 and math.abs(simulatedX) < ResolutionWidth/2 and math.abs(simulatedY) < ResolutionHeight/2 then\n        local count = 1\n        local closestMatch = nil\n        local distanceToClosest = nil\n        for k,v in pairs(Atlas()[0]) do\n            local x = v.center.x/MapXRatio -- 1.1\n            local y = v.center.y/MapYRatio -- 1.4\n            -- So our map is 30% from top, 25% from left, and it's 50% width\n            -- Our simulatedX and Y are already offsets from center\n            -- So if we move it down by 10% and scale it.  So fucking why doesn't it work\n            \n            local convertedX = simulatedX/2*1.1\n            local convertedY = 1.4*((simulatedY/2)-ResolutionHeight/20)\n            local dist = math.sqrt((x-convertedX)*(x-convertedX)+(y-convertedY)*(y-convertedY))\n            if distanceToClosest == nil or dist < distanceToClosest then\n                closestMatch = count\n                distanceToClosest = dist\n            end\n            count = count + 1\n        end\n        if distanceToClosest < 30 then\n            --AutopilotTargetIndex = closestMatch\n            --UpdateAutopilotTarget()\n        end\n    end\nend\n\nfunction DrawButton(newContent, toggle, hover, x, y, w, h, activeColor, inactiveColor, activeText, inactiveText)\n    newContent[#newContent + 1] = stringf(\"<rect rx='5' ry='5' x='%f' y='%f' width='%f' height='%f' fill='\",x, y, w, h)\n    if toggle then \n        newContent[#newContent + 1] = stringf(\"%s'\", activeColor)\n    else\n        newContent[#newContent + 1] = inactiveColor\n    end\n    if hover then \n        newContent[#newContent + 1] = \" style='stroke:white; stroke-width:2'\"\n    else\n        newContent[#newContent + 1] = \" style='stroke:black; stroke-width:1'\"\n    end    \n    newContent[#newContent + 1] = \"></rect>\"\n    newContent[#newContent + 1] = stringf(\"<text x='%f' y='%f' font-size='24' fill='\", x + w/2, y + (h/2) + 5)\n    if toggle then\n        newContent[#newContent + 1] = \"black\"\n    else\n        newContent[#newContent + 1] = \"white\"\n    end\n    newContent[#newContent + 1] = \"' text-anchor='middle' font-family='Montserrat'>\"\n    if toggle then \n        newContent[#newContent + 1] = stringf(\"%s</text>\", activeText)\n    else\n        newContent[#newContent + 1] = stringf(\"%s</text>\", inactiveText)\n    end\nend\n\nfunction DrawButtons(newContent)\n    local defaultColor = \"rgb(0,18,133)'\"\n    local draw = DrawButton\n\n    -- Brake button\n    draw(newContent, brakeToggle, BrakeButtonHovered, ButtonBrakeX, ButtonBrakeY, ButtonBrakeWidth, ButtonBrakeHeight, \"#CC0000\", defaultColor, \"Disable Brake Toggle\", \"Enable Brake Toggle\")\n\n    -- Prograde button\n    draw(newContent, ProgradeIsOn, ProgradeButtonHovered, ButtonProgradeX, ButtonProgradeY, ButtonProgradeWidth, ButtonProgradeHeight, \"#FFEECC\", defaultColor, \"Disable Prograde\", \"Align Prograde\")\n\n    -- Retrograde button\n    draw(newContent, RetrogradeIsOn, RetrogradeButtonHovered, ButtonRetrogradeX, ButtonRetrogradeY, ButtonRetrogradeWidth, ButtonRetrogradeHeight, \"#42006b\", defaultColor, \"Disable Retrograde\", \"Align Retrograde\")\n\n    -- Autopilot button\n    draw(newContent, Autopilot, AutopilotButtonHovered, ButtonAutopilotX, ButtonAutopilotY, ButtonAutopilotWidth, ButtonAutopilotHeight, \"red\", defaultColor, \"Disable Autopilot\", stringf(\"Engage Autopilot: %s</text>\",AutopilotTargetName))\n\n    -- AltitudeHold button\n    draw(newContent, AltitudeHold, AltitudeHoldButtonHovered, ButtonAltitudeHoldX, ButtonAltitudeHoldY, ButtonAltitudeHoldWidth, ButtonAltitudeHoldHeight, \"#42006b\", defaultColor, \"Disable Altitude Hold\", \"Enable Altitude Hold\")\n\n    -- Takeoff button\n    draw(newContent, AutoTakeoff, TakeoffButtonHovered, ButtonTakeoffX, ButtonTakeoffY, ButtonTakeoffWidth, ButtonTakeoffHeight, \"#42006b\", defaultColor, \"Cancel Takeoff\", \"Begin Takeoff\")\n\n    -- Landing button\n    draw(newContent, AutoLanding, LandingButtonHovered, ButtonLandingX, ButtonLandingY, ButtonLandingWidth, ButtonLandingHeight, \"#42006b\", defaultColor, \"Cancel Landing\", \"Begin Landing\")\n\n    -- TurnBurn button\n    draw(newContent, TurnBurn, TurnBurnButtonHovered, ButtonTurnBurnX, ButtonTurnBurnY, ButtonTurnBurnWidth, ButtonTurnBurnHeight, \"#42006b\", defaultColor, \"Disable Turn&Burn\", \"Enable Turn&Burn\")\n\n    -- FollowMode button\n    draw(newContent, FollowMode, FollowModeButtonHovered, ButtonFollowModeX, ButtonFollowModeY, ButtonFollowModeWidth, ButtonFollowModeHeight, \"#42006b\", defaultColor, \"Disable Follow Mode\", \"Enable Follow Mode\")\nend\n\nfunction DrawTank(newContent, updateTanks, x, nameSearchPrefix, nameReplacePrefix, tankTable, fuelTimeLeftTable, fuelPercentTable)                \n    local tankID = 1\n    local tankName = 2\n    local tankMaxVol = 3\n    local tankMassEmpty = 4\n    local tankLastMass = 5\n    local tankLastTime = 6\n\n    local y1 = 350\n    local y2 = 360\n    if Nav.control.isRemoteControlled() == 1 then\n        y1 = y1-50\n        y2 = y2-50\n    end\n\n    if (#tankTable > 0) then\n        for i = 1, #tankTable do\n            if updateTanks or fuelTimeLeftTable[i] == nil or fuelPercentTable[i] == nil then\n                local fuelMassMax = 0\n                local fuelMassLast = 0\n                local fuelMass = 0\n                local fuelLastTime = 0\n                local curTime = system.getTime()\n                fuelMass = (core.getElementMassById(tankTable[i][tankID])-tankTable[i][tankMassEmpty])\n                fuelMassMax = tankTable[i][tankMaxVol]\n                fuelPercentTable[i] = mfloor(fuelMass*100/fuelMassMax)\n                fuelMassLast = tankTable[i][tankLastMass]\n                fuelLastTime = tankTable[i][tankLastTime]\n                if fuelMassLast <= fuelMass then\n                    fuelTimeLeftTable[i] = 0\n                else\n                    fuelTimeLeftTable[i] = mfloor(fuelMass / ((fuelMassLast - fuelMass) / (curTime - fuelLastTime)))\n                end\n                tankTable[i][tankLastMass] = fuelMass\n                tankTable[i][tankLastTime] = curTime\n            end\n            local name = string.sub(tankTable[i][tankName], 1, 12)\n            if name == nameSearchPrefix then \n                name = stringf(\"%s %d\", nameReplacePrefix, i)\n            end\n            local fuelTimeDisplay\n            if fuelTimeLeftTable[i] == 0 then \n                fuelTimeDisplay = \"n/a\" \n            else\n                fuelTimeDisplay = FormatTimeString(fuelTimeLeftTable[i])\n            end\n            if fuelPercentTable[i] ~= nil then\n                local colorMod = mfloor(fuelPercentTable[i]*2.55)\n                local color = stringf(\"rgb(%d,%d,%d)\", 255-colorMod, colorMod, 0)\n                if ((fuelTimeDisplay ~= \"n/a\" and fuelTimeLeftTable[i] < 120) or fuelPercentTable[i] < 5) then\n                    if updateTanks then \n                        if titlecol == rgbO then\n                            titlecol = \"rgb(255,0,0)\"\n                        else\n                            titlecol = rgbO\n                        end\n                    end\n                end\n                newContent[#newContent + 1] = stringf([[\n                    <g class=\"text\">\n                        <g font-size=11>\n                            <text x=%d y=\"%d\" text-anchor=\"start\" style=\"fill:%s\">%s</text>\n                            <text x=%d y=\"%d\" text-anchor=\"start\" style=\"fill:%s\">%d%% %s</text>\n                        </g>\n                    </g>]], x, y1, titlecol, name, x, y2, color, fuelPercentTable[i], fuelTimeDisplay)\n                y1 = y1+30\n                y2 = y2+30\n            end\n        end\n    end\nend\n\nfunction HideInterplanetaryPanel()\n    system.destroyWidgetPanel(panelInterplanetary)\n    panelInterplanetary = nil\nend\n\nfunction ToggleTurnBurn()\n    TurnBurn = not TurnBurn\nend\n\nfunction ToggleAltitudeHold()\n        AltitudeHold = not AltitudeHold\n        if AltitudeHold then\n            AutoBrake = false\n            Autopilot = false\n            ProgradeIsOn = false\n            RetrogradeIsOn = false\n            if not FollowMode then\n                OldAutoRoll = autoRoll\n            end\n            FollowMode = false\n            AutoLanding = false\n            autoRoll = true\n            if (not gearExtended and not BrakeIsOn) or atmosphere() == 0 then -- Never autotakeoff in space\n                AutoTakeoff = false\n                HoldAltitude = core_altitude\n                if Nav.axisCommandManager:getAxisCommandType(0) == 0 then\n                    Nav.control.cancelCurrentControlMasterMode()\n                end\n            else\n                AutoTakeoff = true\n                HoldAltitude = core_altitude + AutoTakeoffAltitude\n                gearExtended = false\n                Nav.control.retractLandingGears()\n                Nav.axisCommandManager:setTargetGroundAltitude(500)\n                BrakeIsOn = true -- Engage brake for warmup\n            end\n        else\n            autoRoll = OldAutoRoll\n            AutoTakeoff = false\n            AutoLanding = false\n        end\nend  \n\n-- HUD - https://github.com/Rezoix/DU-hud with major modifications by Archeageo\nfunction updateHud(newContent)\n\n    local altitude = core_altitude\n    local velocity = core.getVelocity()\n    local speed = vec3(velocity):len()\n    local worldV = vec3(core.getWorldVertical())\n    local constrF = vec3(core.getConstructWorldOrientationForward())\n    local constrR = vec3(core.getConstructWorldOrientationRight())\n    local constrV = vec3(core.getConstructWorldOrientationUp())\n    local pitch = getPitch(worldV, constrF, constrR)--180 - getRoll(worldV, constrR, constrF)\n    local roll = getRoll(worldV, constrF, constrR) --getRoll(worldV, constrF, constrR)\n    local originalRoll = roll\n    local originalPitch = mfloor(pitch)\n    local bottomText = \"ROLL\"\n    local grav = core.getWorldGravity()\n    local gravity = vec3(grav):len()\n    local atmos = atmosphere()\n    local throt = mfloor(unit.getThrottle())\n    local spd = speed*3.6\n    local flightValue = unit.getAxisCommandValue(0)\n    local flightStyle = GetFlightStyle()\n    rgbO = rgb\n    rgbdimO = rgbdim\n    rgbdimmerO = rgbdimmer\n    if system.isViewLocked() == 0 and userControlScheme ~= \"Keyboard\" and Nav.control.isRemoteControlled() == 0 and not brightHud then\n            rgb = [[rgb(]] .. mfloor(PrimaryR *0.4 + 0.5) .. \",\" .. mfloor(PrimaryG * 0.4 + 0.5) .. \",\" .. mfloor(PrimaryB * 0.3 + 0.5) .. [[)]]\n            rgbdim = [[rgb(]] .. mfloor(PrimaryR *0.3 + 0.5) .. \",\" .. mfloor(PrimaryG * 0.3 + 0.5) .. \",\" .. mfloor(PrimaryB * 0.2 + 0.5) .. [[)]]\n            rgbdimmer = [[rgb(]] .. mfloor(PrimaryR *0.2 + 0.5) .. \",\" .. mfloor(PrimaryG * 0.2 + 0.5) .. \",\" .. mfloor(PrimaryB * 0.1 + 0.5) .. [[)]]\n    end\n\n    if (atmos == 0) then\n        if (speed > 5) then\n            pitch = getRelativePitch(velocity)\n            roll = getRelativeYaw(velocity)\n        else\n            pitch = 0\n            roll = 0\n        end\n        bottomText = \"YAW\"\n    end\n\n    -- SVG START\n\n    newContent[#newContent + 1] = stringf([[\n    <head>\n        <style>\n            body {margin: 0}\n            svg {position:absolute; top:0; left:0} \n            .majorLine {stroke:%s;stroke-width:3;fill:none;}\n            .minorLine {stroke:%s;stroke-width:3;fill:none;}\n            .text {fill:%s;font-family:Montserrat;font-weight:bold}\n        </style>\n    </head>\n    <body>\n        <svg height=\"100vh\" width=\"100vw\" viewBox=\"0 0 1920 1080\">\n        ]], rgbO, rgb, rgbdimmer)\n    \n    -- CRUISE/ODOMETER\n\n    newContent[#newContent + 1] = LastOdometerOutput\n\n    -- DAMAGE\n\n    newContent[#newContent + 1] = damageMessage\n\n    -- RADAR\n\n    newContent[#newContent + 1] = radarMessage\n    \n    -- FUEL TANKS\n    \n    if (UpdateCount % FuelUpdateDelay == 0) then updateTanks = true end\n    \n    DrawTank(newContent, updateTanks, 1700, \"Atmospheric \", \"ATMO\", atmoTanks, fuelTimeLeft, fuelPercent)\n    DrawTank(newContent, updateTanks, 1800, \"Space fuel t\", \"SPACE\", spaceTanks, fuelTimeLeftS, fuelPercentS)\n    DrawTank(newContent, updateTanks, 1600, \"Rocket fuel \", \"ROCKET\", rocketTanks, fuelTimeLeftR, fuelPercentR)\n\n    if updateTanks then\n        updateTanks = false\n        UpdateCount = 0\n    end\n    UpdateCount = UpdateCount + 1\n\n    -- PRIMARY FLIGHT INSTRUMENTS\n\n    DrawVerticalSpeed(newContent, altitude, atmos) -- Weird this is draw during remote control...?\n    \n    if Nav.control.isRemoteControlled() == 0 then     \n        DrawThrottle(newContent, flightStyle, throt, flightValue)                   \n        DrawPitchDisplay(newContent, pitch)\n        -- Don't even draw this in freelook\n        if rgb == rgbO then\n            DrawArtificialHorizon(newContent, originalPitch, originalRoll, atmos)\n        end\n        DrawRollDisplay(newContent, roll, bottomText)\n        DrawAltitudeDisplay(newContent, altitude, atmos)\n    end   \n\n    -- PRIMARY DATA DISPLAYS\n\n    DrawSpeedGravityAtmosphere(newContent, spd, gravity, atmos)                          \n\n    -- After the HUD, set RGB values back to undimmed even if view is unlocked\n    rgb = rgbO\n    rgbdim = rgbdimO\n    rgbdimmer = rgbdimmerO\n    DrawWarnings(newContent)                    \n    DisplayOrbit(newContent)                \n    newContent[#newContent + 1] = [[</svg>]]\n    if screen_2 then\n        local pos = vec3(core.getConstructWorldPos())\n        local x = 960+pos.x/MapXRatio\n        local y = 450+pos.y/MapYRatio\n        screen_2.moveContent(YouAreHere, (x-80)/19.2, (y-80)/10.8)\n    end\nend\n\nfunction DrawSpeedGravityAtmosphere(newContent, spd, gravity, atmos)\n    local ys1 = 375\n    local ys2 = 390\n    local xg = 1200\n    local yg1 = 710\n    local yg2 = 720\n    if Nav.control.isRemoteControlled() == 1 then\n        ys1 = 60\n        ys2 = 75\n        xg = 1120\n        yg1 = 55\n        yg2 = 65\n    else -- We only show atmo when not remote\n        newContent[#newContent + 1] = stringf([[\n            <text x=\"770\" y=\"710\" text-anchor=\"end\">ATMOSPHERE</text>\n            <text x=\"770\" y=\"720\" text-anchor=\"end\">%.2f m</text>\n        </g>]], atmos)\n    end\n    newContent[#newContent + 1] = stringf([[\n        <g class=\"text\">\n            <g font-size=10>\n                <text x=\"960\" y=\"%d\" text-anchor=\"middle\" style=\"fill:%s\">SPEED</text>\n                <text x=\"960\" y=\"%d\" text-anchor=\"middle\" style=\"fill:%s;font-size:14;\">%d km/h</text>\n                <text x=\"%d\" y=\"%d\" text-anchor=\"end\">GRAVITY</text>\n                <text x=\"%d\" y=\"%d\" text-anchor=\"end\">%.2f m/s2</text>\n            </g>\n        </g>]], ys1, rgbO, ys2, rgbO, mfloor(spd), xg, yg1, xg, yg2, gravity)\nend\n\nfunction DrawOdometer(newContent, totalDistanceTrip, totalDistanceTravelled, flightStyle, flightTime)\n    local maxBrake = jdecode(unit.getData()).maxBrake\n    if maxBrake ~= nil then LastMaxBrake = maxBrake end\n    maxThrust = Nav:maxForceForward()\n    totalMass = constructMass()\n    newContent[#newContent + 1] = [[<g class=\"majorLine\">\n            <path d=\"M 700 0 L 740 35 Q 960 55 1180 35 L 1220 0\"/>\n        </g>]]\n\n    if Nav.control.isRemoteControlled() == 0 then\n        newContent[#newContent + 1] = stringf([[\n            <g class=\"text\">\n                <g font-size=15>\n                    <text x=\"960\" y=\"20\" text-anchor=\"middle\" style=\"fill:%s;font-size:10;\">Trip Time: %s</text>\n                    <text x=\"960\" y=\"30\" text-anchor=\"middle\" style=\"fill:%s;font-size:10;\">Total Time: %s</text>\n                    <text x=\"740\" y=\"20\" text-anchor=\"start\" style=\"fill:%s;font-size:10;\">Trip: %.2f km</text>\n                    <text x=\"740\" y=\"30\" text-anchor=\"start\" style=\"fill:%s;font-size:10;\">Lifetime: %.2f Mm</text>\n                    <text x=\"1180\" y=\"20\" text-anchor=\"end\" style=\"fill:%s;font-size:10;\">Max Thrust: %.2f kN</text>\n                    <text x=\"1180\" y=\"30\" text-anchor=\"end\" style=\"fill:%s;font-size:10;\">Max Brake: %.2f kN</text>\n                    <text x=\"1180\" y=\"10\" text-anchor=\"end\" style=\"fill:%s;font-size:10;\">Mass: %.2f Tons</text>\n                    <text x=\"960\" y=\"360\" text-anchor=\"middle\" style=\"fill:%s\">%s</text>\n                </g>\n            </g>]], rgbO, FormatTimeString(flightTime), rgbO, FormatTimeString(totalFlightTime), rgbO, totalDistanceTrip, rgbO, (totalDistanceTravelled/1000), rgbO, (maxThrust/1000), rgbO, (LastMaxBrake/1000), rgbO, (totalMass/1000), rgbO, flightStyle)\n    else -- If remote controlled, draw stuff near the top so it's out of the way\n        newContent[#newContent + 1] = stringf([[\n            <g class=\"text\">\n                <g font-size=15>\n                    <text x=\"960\" y=\"33\" text-anchor=\"middle\" style=\"fill:%s\">%s</text>\n                </g>\n            </g>]], rgbO, flightStyle)\n    end\nend\n\nfunction DrawThrottle(newContent, flightStyle, throt, flightValue)\n    newContent[#newContent + 1] = stringf([[\n        <g class=\"minorLine\">\n            <path d=\"M 792 550 L 785 550 L 785 650 L 792 650\"/>\n        </g>\n        <g>\n            <polygon points=\"1138,540 1120,535 1120,545\" style=\"fill:%s\"/>\n        </g>]], rgb)\n    newContent[#newContent + 1] = stringf([[<g transform=\"translate(0 %d)\">\n        <polygon points=\"798,650 810,647 810,653\" style=\"fill:%s;\"/></g>]], (1-throt), rgbdim)\n\n    local y1 = 665\n    local y2 = 675\n    if Nav.control.isRemoteControlled() == 1 then\n        y1 = 55\n        y2 = 65\n    end\n\n    if (flightStyle == \"TRAVEL\" or flightStyle == \"AUTOPILOT\") then\n        newContent[#newContent + 1] = stringf([[\n            <g class=\"text\">\n                <g font-size=10>\n                    <text x=\"783\" y=\"%d\" text-anchor=\"start\" style=\"fill:%s\">THROT</text>\n                    <text x=\"783\" y=\"%d\" text-anchor=\"start\" style=\"fill:%s\">%d%%</text>\n                </g>\n            </g>]], y1, rgbO, y2, rgbO, throt)\n    else\n            newContent[#newContent + 1] = stringf([[\n            <g class=\"text\">\n                <g font-size=10>\n                    <text x=\"783\" y=\"%d\" text-anchor=\"start\" style=\"fill:%s\">CRUISE</text>\n                    <text x=\"783\" y=\"%d\" text-anchor=\"start\" style=\"fill:%s\">%d km/h</text>\n                </g>\n            </g>]], y1, rgbO, y2, rgbO, flightValue)\n    end\nend\n\n-- Draw vertical speed indicator - Code by lisa-lionheart \nfunction DrawVerticalSpeed(newContent, altitude, atmos) \n    if (altitude < 200000 and atmos == 0 ) or (altitude and atmos > 0) then \n        local velocity = vec3(core.getWorldVelocity())\n        local up = vec3(core.getWorldVertical()) * -1\n        local vSpd = (velocity.x * up.x) + (velocity.y * up.y) + (velocity.z * up.z)\n        local angle = 0       \n        if math.abs(vSpd) > 1 then\n            angle = 45 * math.log(math.abs(vSpd), 10)      \n            if vSpd < 0 then\n                angle = -angle\n            end                                \n        end\n        newContent[#newContent + 1] =  stringf([[\n            <g transform=\"translate(1525 250) scale(0.6)\">\n                <g font-size=\"14px\" font-family=\"sans-serif\" fill=\"%s\">\n                    <text x=\"31\" y=\"-41\">1000</text>\n                    <text x=\"-10\" y=\"-65\">100</text>\n                    <text x=\"-54\" y=\"-45\">10</text>\n                    <text x=\"-73\" y=\"3\">O</text>\n                    <text x=\"-56\" y=\"52\">-10</text>\n                    <text x=\"-14\" y=\"72\">-100</text>\n                    <text x=\"29\" y=\"50\">-1000</text>\n                    <text x=\"85\" y=\"0\" font-size=\"20px\" text-anchor=\"end\" >%d m/s</text>\n                </g>\n                <g fill=\"none\" stroke=\"%s\" stroke-width=\"3px\">\n                    <path d=\"m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7\"/>\n                    <circle r=\"90\" />\n                </g>\n                <path transform=\"rotate(%d)\" fill=\"%s\" d=\"m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z\" />\n            </g>\n        ]], rgbO, mfloor(vSpd), rgbO, mfloor(angle), rgbO)\n    end\nend\n\nfunction DrawPitchDisplay(newContent, pitch)\n    -- PITCH DISPLAY\n    local pitchC = mfloor(pitch)\n    local len = 0\n    for i = mfloor(pitchC-25-pitchC%5+0.5),mfloor(pitchC+25+pitchC%5+0.5),5 do\n        if (i%10==0) then\n            num = i\n            if (num > 180) then\n                num = -180 + (num-180)\n            elseif (num < -180) then\n                num = 180 + (num+180)\n            end\n            newContent[#newContent + 1] = stringf([[\n                <g transform=\"translate(0 %f)\">\n                    <text x=\"1180\" y=\"540\" style=\"fill:%s;text-anchor:start;font-size:12;font-family:Montserrat;font-weight:bold\">%d</text></g>]], (-i*5 + pitch*5 + 5), rgbdim, num)\n        end\n        if (i%10==0) then\n            len = 30\n        elseif (i%5==0) then\n            len = 20\n        else\n            len = 7\n        end\n        newContent[#newContent + 1] = stringf([[\n            <g transform=\"translate(0 %f)\">\n                <line x1=\"%d\" y1=\"540\" x2=\"1140\" y2=\"540\"style=\"stroke:%s;stroke-width:2\"/></g>]], (-i*5 + pitch*5), (1140+len), rgbdim)\n    end\n    newContent[#newContent + 1] = stringf([[\n        <g class=\"text\">\n            <g font-size=10>\n                <text x=\"1180\" y=\"380\" text-anchor=\"end\" style=\"fill:%s\">PITCH</text>\n                <text x=\"1180\" y=\"390\" text-anchor=\"end\" style=\"fill:%s\">%d deg</text>\n            </g>\n        </g>\n    ]], rgbdimmerO, rgbdimmerO, pitchC)\nend\n\nfunction DrawAltitudeDisplay(newContent, altitude, atmos)\n    if (altitude < 200000 and atmos == 0 ) or (altitude and atmos > 0) then    \n        newContent[#newContent + 1] = stringf([[\n        <g>\n            <polygon points=\"782,540 800,535 800,545\" style=\"fill:%s\"/>\n        </g>\n        <g class=\"text\">\n        <g font-size=10>\n            <text x=\"770\" y=\"380\" text-anchor=\"end\" style=\"fill:%s\">ALTITUDE</text>\n            <text x=\"770\" y=\"390\" text-anchor=\"end\" style=\"fill:%s\">%d m</text>\n            ]], rgb, rgbdimmerO, rgbdimmerO, mfloor(altitude))\n\n        newContent[#newContent + 1] = stringf([[\n            <text x=\"770\" y=\"710\" text-anchor=\"end\">ATMOSPHERE</text>\n            <text x=\"770\" y=\"720\" text-anchor=\"end\">%.2f m</text>\n        </g>\n        </g>]], atmos)\n\n            -- Many thanks to Nistus on Discord for his assistance with the altimeter.\n        local altC = mfloor((altitude)/10)\n        local num = 0\n        local len = 0\n        for i = mfloor(altC-25-altC%5+0.5),mfloor(altC+25+altC%5+0.5),5 do\n            if (i%10==0) then\n                num = i*10\n                newContent[#newContent + 1] = stringf([[<g transform=\"translate(0 %f)\">\n                    <text x=\"745\" y=\"540\" style=\"fill:%s;text-anchor:end;font-size:12;font-family:Montserrat;font-weight:bold\">%d</text></g>]], (-i*5 + altitude*.5+5), rgbdim, num)\n            end\n            len = 5\n            if (i%10==0) then\n                len = 30\n            elseif (i%5==0) then\n                len = 15\n            end\n            newContent[#newContent + 1] = stringf([[\n                <g transform=\"translate(0 %f)\">\n                <line x1=\"%d\" y1=\"540\" x2=\"780\" y2=\"540\"style=\"stroke:%s;stroke-width:2\"/></g>]], (-i*5 + altitude*.5), (780-len), rgbdimmer)\n        end\n    end\nend\n\n\nfunction DrawArtificialHorizon(newContent, originalPitch, originalRoll, atmos)\n    --** CIRCLE ALTIMETER  - Base Code from Discord @Rainsome = Youtube CaptainKilmar** \n    local horizonRadius = circleRad -- Aliased global\n    if horizonRadius > 0 and unit.getClosestPlanetInfluence() > 0 then\n        if originalPitch > 90 and atmos == 0 then\n            originalPitch = 90-(originalPitch-90)\n        elseif originalPitch < -90 and atmos == 0 then\n            originalPitch = -90 - (originalPitch+90)\n        end\n        newContent[#newContent + 1] = stringf([[\n            <circle r=\"%f\" cx=\"960\" cy=\"540\" opacity=\"0.1\" fill=\"#0083cb\" stroke=\"black\" stroke-width=\"2\"/>\n                <clipPath id=\"cut\"><circle r=\"%f\" cx=\"960\" cy=\"540\"/></clipPath>\n                <rect x=\"%f\" y=\"%f\" height=\"%f\" width=\"%f\" opacity=\"0.3\" fill=\"#6b5835\" clip-path=\"url(#cut)\" transform=\"rotate(%f 960 540)\"/>]], horizonRadius, (horizonRadius-1), (960-horizonRadius), (540 + horizonRadius*(originalPitch/90)),(horizonRadius*2), (horizonRadius*2), (-1*originalRoll))\n        \n    end\nend\n\nfunction DrawRollDisplay(newContent, roll, bottomText)\n    local rollC = mfloor(roll)\n    newContent[#newContent + 1] = stringf([[\n        <g class=\"text\">\n        <g font-size=10>\n        <text x=\"960\" y=\"688\" text-anchor=\"middle\" style=\"fill:%s\">%s</text>\n        <text x=\"960\" y=\"698\" text-anchor=\"middle\" style=\"fill:%s\">%d deg</text>]],rgbdimmerO, bottomText, rgbdimmerO, mfloor(roll))\n    newContent[#newContent + 1] = stringf([[<g>\n        <polygon points=\"960,725 955,707 965,707\" style=\"fill:%s\"/>\n        </g>]], rgb)\n\n    local sign = 0\n    local num = 0\n    local len = 0\n    for i = mfloor(rollC-30-rollC%5+0.5),mfloor(rollC+30+rollC%5+0.5),5 do\n        if (i%10==0) then\n            sign = i/math.abs(i)\n            if i == 0 then\n                sign = 0\n            end\n            num = math.abs(i)\n            if (num > 180) then\n                num = 180 + (180-num) \n            end\n            newContent[#newContent + 1] = stringf([[<g transform=\"rotate(%f,960,460)\">\n                <text x=\"960\" y=\"760\" style=\"fill:%s;text-anchor:middle;font-size:12;font-family:Montserrat;font-weight:bold\">%d</text></g>]], (i - roll), rgbdim, mfloor(sign*num+0.5))\n            end\n        len = 5\n        if (i%10==0) then\n            len = 15\n        elseif (i%5==0) then\n            len = 10\n        end\n        newContent[#newContent + 1] = stringf([[<g transform=\"rotate(%f,960,460)\">\n            <line x1=\"960\" y1=\"730\" x2=\"960\" y2=\"%d\" style=\"stroke:%s;stroke-width:2\"/></g>]], (i - roll), (730+len), rgbdimmer)\n    end\nend\n\nfunction DrawWarnings(newContent)\n    if unit.isMouseControlActivated() == 1 then\n        newContent[#newContent + 1] = \"<text x='960' y='550' font-size='26' font-weight='bold' fill='red' text-anchor='middle' font-family='Bank'>Warning: Invalid Control Scheme Detected</text>\"\n        newContent[#newContent + 1] = \"<text x='960' y='600' font-size='26' font-weight='bold' fill='red' text-anchor='middle' font-family='Bank'>Keyboard Scheme must be selected</text>\"\n        newContent[#newContent + 1] = \"<text x='960' y='650' font-size='26' font-weight='bold' fill='red' text-anchor='middle' font-family='Bank'>Set your preferred scheme in Lua Parameters instead</text>\"\n    end\n    local warningX = 960\n    local brakeY = 860\n    local gearY = 900\n    local hoverY = 930\n    local apY = 225\n    local turnBurnY = 150\n    local gyroY = 960\n    if Nav.control.isRemoteControlled() == 1 then\n        brakeY = 135\n        gearY = 155\n        hoverY = 175\n        apY = 115\n        turnBurnY = 95\n    end\n    if BrakeIsOn then\n        newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='26' font-weight='bold' fill='red' text-anchor='middle' font-family='Bank'>Brake Engaged</text>\",warningX, brakeY)\n    end\n    if GyroIsOn then\n        newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='26' font-weight='bold' fill='red' text-anchor='middle' font-family='Bank'>Gyro Enabled</text>\",warningX, gyroY)\n    end\n    if gearExtended then\n        if hasGear then \n            newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='24' fill='orange' text-anchor='middle' font-family='Bank'>Gear Extended</text>\", warningX, gearY)\n        else\n            newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='26' font-weight='bold' fill='red' text-anchor='middle' font-family='Bank'>Landed (G: Takeoff)</text>\", warningX, gearY)\n        end\n        newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='24' fill='orange' text-anchor='middle' font-family='Bank'>Hover Height: %s</text>\", warningX, hoverY, getDistanceDisplayString(Nav:getTargetGroundAltitude()))\n    end\n    if AutoBrake and AutopilotTargetPlanetName ~= \"None\" then\n        if brakeInput == 0 then\n            newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='26' font-weight='bold' fill='orange' text-anchor='middle' font-family='Bank'>Auto-Braking when within %s of %s</text>\", warningX, apY, getDistanceDisplayString(maxBrakeDistance), AutopilotTargetPlanet.name)\n        else\n            newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='26' font-weight='bold' fill='orange' text-anchor='middle' font-family='Bank'>Auto-Braking until eccentricity: %f begins to increase</text>\",warningX, apY, round(orbit.eccentricity,2))\n        end\n    elseif Autopilot and AutopilotTargetPlanetName ~= \"None\" then\n        newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='26' font-weight='bold' fill='orange' text-anchor='middle' font-family='Bank'>Autopilot %s</text>\",warningX, apY, AutopilotStatus)\n    elseif FollowMode then\n        newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='26' font-weight='bold' fill='orange' text-anchor='middle' font-family='Bank'>Follow Mode Engaged</text>\", warningX, apY)\n    elseif AltitudeHold then\n        if AutoLanding then\n            newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='26' font-weight='bold' fill='red' text-anchor='middle' font-family='Bank'>Auto-Landing</text>\", warningX, apY)\n        elseif AutoTakeoff then\n            newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='26' font-weight='bold' fill='orange' text-anchor='middle' font-family='Bank'>Ascent to %s</text>\",warningX, apY, getDistanceDisplayString(HoldAltitude))\n            if BrakeIsOn then\n                newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='28' fill='darkred' text-anchor='middle' font-family='Bank'>Throttle Up and Disengage Brake For Takeoff</text>\", warningX, apY + 50)\n            end\n        else\n            newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='26' font-weight='bold' fill='orange' text-anchor='middle' font-family='Bank'>Altitude Hold: %s</text>\", warningX, apY, getDistanceDisplayString2(HoldAltitude))\n        end\n    end\n    if TurnBurn then\n        newContent[#newContent + 1] = stringf(\"<text x='%d' y='%d' font-size='26' font-weight='bold' fill='darkred' text-anchor='middle' font-family='Bank'>Turn & Burn Braking</text>\", warningX, turnBurnY)\n    end\nend\n\nfunction DisplayOrbit(newContent)\n    if orbit ~= nil and atmosphere() < 0.2 and planet ~= nil then\n        -- If orbits are up, let's try drawing a mockup\n        local orbitMapX = 75\n        local orbitMapY = 0\n        local orbitMapSize = 250 -- Always square\n        local pad = 4\n        orbitMapY = orbitMapY + pad                        \n        local orbitInfoYOffset = 15\n        local x = orbitMapX + orbitMapSize + orbitMapX/2 + pad\n        local y = orbitMapY + orbitMapSize/2 + 5 + pad\n        \n        local rx, ry, scale, xOffset\n        rx = orbitMapSize/4\n        xOffset = 0\n        \n        -- Draw a darkened box around it to keep it visible\n        newContent[#newContent + 1] = stringf('<rect width=\"%f\" height=\"%d\" rx=\"10\" ry=\"10\" x=\"%d\" y=\"%d\" style=\"fill:rgb(0,0,100);stroke-width:4;stroke:white;fill-opacity:0.3;\" />', orbitMapSize+orbitMapX*2, orbitMapSize+orbitMapY, pad, pad)\n\n        if orbit.periapsis ~= nil and orbit.apoapsis ~= nil then\n            scale = (orbit.apoapsis.altitude + orbit.periapsis.altitude + planet.radius*2)/(rx*2)\n            ry = (planet.radius + orbit.periapsis.altitude + (orbit.apoapsis.altitude - orbit.periapsis.altitude)/2)/scale * (1-orbit.eccentricity)\n            xOffset = rx - orbit.periapsis.altitude/scale - planet.radius/scale\n            \n            local ellipseColor = rgbdim\n            if orbit.periapsis.altitude <= 0 then\n                ellipseColor = 'red'\n            end\n            newContent[#newContent + 1] = stringf('<ellipse cx=\"%f\" cy=\"%f\" rx=\"%f\" ry=\"%f\" style=\"fill:none;stroke:%s;stroke-width:2\" />', orbitMapX + orbitMapSize/2 + xOffset + pad, orbitMapY + orbitMapSize/2 + pad, rx, ry, ellipseColor)\n            newContent[#newContent + 1] = stringf('<circle cx=\"%f\" cy=\"%f\" r=\"%f\" stroke=\"white\" stroke-width=\"3\" fill=\"blue\" />', orbitMapX + orbitMapSize/2 + pad, orbitMapY + orbitMapSize/2 + pad, planet.radius/scale) \n        end\n        \n        if orbit.apoapsis ~= nil then\n            newContent[#newContent + 1] = stringf([[<line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\"style=\"stroke:%s;opacity:0.3;stroke-width:3\"/>]],x - 35, y-5, orbitMapX + orbitMapSize/2 + rx + xOffset, y-5, rgbdim)\n            newContent[#newContent + 1] = stringf(\"<text x='%f' y='%f' font-size='14' fill=%s text-anchor='middle' font-family='Montserrat'>Apoapsis</text>\", x, y, rgb)\n            y  = y + orbitInfoYOffset\n            newContent[#newContent + 1] = stringf(\"<text x='%f' y='%f' font-size='12' fill=%s text-anchor='middle' font-family='Montserrat'>%s</text>\", x, y, rgbdimmer,  getDistanceDisplayString(orbit.apoapsis.altitude))\n            y  = y + orbitInfoYOffset\n            newContent[#newContent + 1] = stringf(\"<text x='%f' y='%f' font-size='12' fill=%s text-anchor='middle' font-family='Montserrat'>%s</text>\", x, y, rgbdimmer, FormatTimeString(orbit.timeToApoapsis))\n            y  = y + orbitInfoYOffset\n            newContent[#newContent + 1] = stringf(\"<text x='%f' y='%f' font-size='12' fill=%s text-anchor='middle' font-family='Montserrat'>%s</text>\", x, y, rgbdimmer, getSpeedDisplayString(orbit.apoapsis.speed))\n        end\n        \n        y = orbitMapY + orbitMapSize/2 + 5 + pad\n        x = orbitMapX - orbitMapX/2+10 + pad\n        \n        if orbit.periapsis ~= nil then\n            newContent[#newContent + 1] = stringf(\"<text x='%f' y='%f' font-size='14' fill=%s text-anchor='middle' font-family='Montserrat'>Periapsis</text>\", x, y, rgb)\n            newContent[#newContent + 1] = stringf([[<line x1=\"%f\" y1=\"%f\" x2=\"%f\" y2=\"%f\"style=\"stroke:%s;opacity:0.3;stroke-width:3\"/>]], x + 35, y-5, orbitMapX + orbitMapSize/2 - rx + xOffset, y-5, rgbdim)\n            y  = y + orbitInfoYOffset\n            newContent[#newContent + 1] = stringf(\"<text x='%f' y='%f' font-size='12' fill=%s text-anchor='middle' font-family='Montserrat'>%s</text>\", x, y, rgbdimmer, getDistanceDisplayString(orbit.periapsis.altitude))\n            y  = y + orbitInfoYOffset\n            newContent[#newContent + 1] = stringf(\"<text x='%f' y='%f' font-size='12' fill=%s text-anchor='middle' font-family='Montserrat'>%s</text>\", x, y, rgbdimmer, FormatTimeString(orbit.timeToPeriapsis))\n            y  = y + orbitInfoYOffset\n            newContent[#newContent + 1] = stringf(\"<text x='%f' y='%f' font-size='12' fill=%s text-anchor='middle' font-family='Montserrat'>%s</text>\", x, y, rgbdimmer, getSpeedDisplayString(orbit.periapsis.speed))\n            \n        end\n        \n        -- Add a label for the planet\n        newContent[#newContent + 1] = stringf(\"<text x='%f' y='%d' font-size='18' fill=%s text-anchor='middle' font-family='Montserrat'>%s</text>\", orbitMapX + orbitMapSize/2 + pad, 20 + pad, rgb, planet.name)\n\n        if orbit.period ~= nil and orbit.periapsis ~= nil and orbit.apoapsis ~= nil then\n            local apsisRatio = (orbit.timeToApoapsis/orbit.period) * 2 * math.pi\n            -- x = xr * cos(t)\n            -- y = yr * sin(t)\n            local shipX = rx * math.cos(apsisRatio)\n            local shipY = ry * math.sin(apsisRatio)\n            \n            newContent[#newContent + 1] = stringf('<circle cx=\"%f\" cy=\"%f\" r=\"5\" stroke=\"white\" stroke-width=\"3\" fill=\"white\" />', orbitMapX + orbitMapSize/2 + shipX + xOffset + pad, orbitMapY + orbitMapSize/2 + shipY + pad)\n        end\n        -- Once we have all that, we should probably rotate the entire thing so that the ship is always at the bottom so you can see AP and PE move?\n        \n    end\nend\n\nfunction GetFlightStyle()\n    local flightType = Nav.axisCommandManager:getAxisCommandType(0)\n    local flightStyle = \"TRAVEL\"\n    if (flightType == 1) then\n        flightStyle = \"CRUISE\"\n    end\n    if Autopilot then\n        flightStyle = \"AUTOPILOT\"\n    end\n    return flightStyle\nend\n-- !DU[lib]: flush\n\nfunction flush()\n    local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\n    -- validate params\n    pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)\n    yawSpeedFactor = math.max(yawSpeedFactor, 0.01)\n    rollSpeedFactor = math.max(rollSpeedFactor, 0.01)\n    torqueFactor = math.max(torqueFactor, 0.01)\n    brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\n    brakeFlatFactor = math.max(brakeFlatFactor, 0.01)\n    autoRollFactor = math.max(autoRollFactor, 0.01)\n    turnAssistFactor = math.max(turnAssistFactor, 0.01)\n\n    -- final inputs\n    local finalPitchInput = pitchInput + pitchInput2 + system.getControlDeviceForwardInput()\n    local finalRollInput = rollInput + rollInput2 + system.getControlDeviceYawInput()\n    local finalYawInput = (yawInput + yawInput2) - system.getControlDeviceLeftRightInput()\n    local finalBrakeInput = brakeInput\n\n    -- Axis\n    local worldVertical = vec3(core.getWorldVertical()) -- along gravity\n    local constructUp = vec3(core.getConstructWorldOrientationUp())\n    local constructForward = vec3(core.getConstructWorldOrientationForward())\n    local constructRight = vec3(core.getConstructWorldOrientationRight())\n    local constructVelocity = vec3(core.getWorldVelocity())\n    local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()\n    local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)\n    local currentRollDegAbs = math.abs(currentRollDeg)\n    local currentRollDegSign = utils.sign(currentRollDeg)\n\n    -- Rotation\n    local constructAngularVelocity = vec3(core.getWorldAngularVelocity())\n    local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight\n                                    + finalRollInput * rollSpeedFactor * constructForward\n                                    + finalYawInput * yawSpeedFactor * constructUp\n\n    -- In atmosphere?\n    if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\n        local autoRollRollThreshold = 1.0\n        -- autoRoll on AND currentRollDeg is big enough AND player is not rolling\n        if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n            local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit\n            if (rollPID == nil) then\n                rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n            end\n            rollPID:inject(targetRollDeg - currentRollDeg)\n            local autoRollInput = rollPID:get()\n\n            targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward\n        end\n        local turnAssistRollThreshold = 20.0\n        -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing\n        if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n            local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range\n            local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range\n\n            -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)\n            local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n            local rollVerticalRatio = 0\n            if rescaleRollDegAbs < 90 then\n                rollVerticalRatio = rescaleRollDegAbs / 90\n            elseif rescaleRollDegAbs < 180 then\n                rollVerticalRatio = (180 - rescaleRollDegAbs) / 90\n            end\n\n            rollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n\n            local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n            local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio\n\n            targetAngularVelocity = targetAngularVelocity\n                                + turnAssistPitchInput * constructRight\n                                + turnAssistYawInput * constructUp\n        end\n    end\n\n    -- Engine commands\n    local keepCollinearity = 1 -- for easier reading\n    local dontKeepCollinearity = 0 -- for easier reading\n    local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\n    -- Rotation\n    local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)\n    local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())\n    angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction\n    Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n    -- Brakes\n    local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\n    Nav:setEngineForceCommand('brake', brakeAcceleration)\n\n    -- AutoNavigation regroups all the axis command by 'TargetSpeed'\n    local autoNavigationEngineTags = ''\n    local autoNavigationAcceleration = vec3()\n    local autoNavigationUseBrake = false\n\n    -- Longitudinal Translation\n    local longitudinalEngineTags = 'thrust analog longitudinal'\n    local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\n    if (longitudinalCommandType == axisCommandType.byThrottle) then\n        local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n        Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)\n    elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n        local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n        autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n        autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\n        if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n            Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking\n        then\n            autoNavigationUseBrake = true\n        end\n\n    end\n\n    -- Lateral Translation\n    local lateralStrafeEngineTags = 'thrust analog lateral'\n    local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\n    if (lateralCommandType == axisCommandType.byThrottle) then\n        local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n        Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)\n    elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then\n        local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n        autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\n        autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration\n    end\n\n    -- Vertical Translation\n    local verticalStrafeEngineTags = 'thrust analog vertical'\n    local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\n    if (verticalCommandType == axisCommandType.byThrottle) then\n        local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n        if upAmount ~= 0 or AutoLanding then\n            Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\n        else\n            Nav:setEngineForceCommand(verticalStrafeEngineTags, vec3(), keepCollinearity)\n        end\n    elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then\n        local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n        autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\n        autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration\n    end\n\n    -- Auto Navigation (Cruise Control)\n    if (autoNavigationAcceleration:len() > constants.epsilon) then\n        if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n        then\n            autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n        end\n        Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\n    end\n\n    -- Rockets\n    Nav:setBoosterCommand('rocket_engine')\n    -- Dodgin's Don't Die Rocket Govenor - Cruise Control Edition\n    speed = vec3(core.getVelocity()):len() \n    cc_speed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)                \n    if Nav.axisCommandManager:getAxisCommandType(0) == 1 and (speed * 3.6 > cc_speed) then \n            unit.setEngineThrust('rocket_engine',0)                \n    elseif(isboosting) then \n            unit.setEngineThrust('rocket_engine',1)                \n    end\nend    ",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": -2
      },
      "key": 1
    },
    {
      "code": "-- !DU: main\n-- function localizations\nlocal mfloor = math.floor\nlocal stringf = string.format\nlocal jdecode = json.decode\nlocal jencode = json.encode\nlocal eleMaxHp = core.getElementMaxHitPointsById\nlocal atmosphere = unit.getAtmosphereDensity\nlocal eleHp = core.getElementHitPointsById\nlocal eleType = core.getElementTypeById\nlocal constructMass = core.getConstructMass\n\n\n\n\n",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": -1
      },
      "key": 2
    },
    {
      "code": "    -- category panel display helpers\n    _autoconf = {}\n    _autoconf.panels = {}\n    _autoconf.panels_size = 0\n    _autoconf.displayCategoryPanel = function(elements, size, title, type, widgetPerData)\n        widgetPerData = widgetPerData or false -- default to one widget for all data\n        if size > 0 then\n            local panel = system.createWidgetPanel(title)\n            local widget\n            if not widgetPerData then\n                widget = system.createWidget(panel, type)\n            end\n            for i = 1, size do\n                if widgetPerData then\n                    widget = system.createWidget(panel, type)\n                end\n                system.addDataToWidget(elements[i].getDataId(), widget)\n            end\n            _autoconf.panels_size = _autoconf.panels_size + 1\n            _autoconf.panels[_autoconf.panels_size] = panel\n        end\n    end\n    _autoconf.hideCategoryPanels = function()\n        for i=1,_autoconf.panels_size do\n            system.destroyWidgetPanel(_autoconf.panels[i])\n        end\n    end\n    -- Proxy array to access auto-plugged slots programmatically\n\n    radar = {}\n    radar[1] = radar_1\n    radar_size = 1\n\n    weapon = {}\n    weapon_size = 0\n\n    door = {}\n    door_size = 0\n\n    forcefield = {}\n    forcefield_size = 0\n\n    atmofueltank = {}\n    atmofueltank[1] = atmofueltank_1\n    atmofueltank_size = 1\n\n    spacefueltank = {}\n    spacefueltank[1] = spacefueltank_1\n    spacefueltank_size = 1\n\n    rocketfueltank = {}\n    rocketfueltank_size = 0\n    -- End of auto-generated code\n    Nav = Navigator.new(system, core, unit)\n    Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})\n\n    -- GLOBAL VARIABLES SECTION, IF NOT USED OUTSIDE UNIT.START, MAKE IT LOCAL\n    LastMaxBrake = 0\n    mousePitchFactor = 1 -- Mouse control only\n    mouseYawFactor = 1 -- Mouse control only\n    hasGear = false\n    pitchInput = 07\n    rollInput = 0\n    yawInput = 0\n    brakeInput = 0\n    pitchInput2 = 0\n    rollInput2 = 0\n    yawInput2 = 0\n    BrakeIsOn = false\n    RetrogradeIsOn = false             \n    ProgradeIsOn = false             \n    AutoBrake = false\n    Autopilot = false\n    FollowMode = false\n    TurnBurn = false\n    AltitudeHold = false\n    AutoLanding = false\n    AutoTakeoff = false\n    HoldAltitude = 1000 -- In case something goes wrong, give this a decent start value\n    AutopilotAccelerating = false\n    AutopilotBraking = false\n    AutopilotCruising = false \n    AutopilotRealigned = false\n    AutopilotEndSpeed = 0\n    AutopilotStatus = \"Aligning\"\n    simulatedX = 0\n    simulatedY = 0\n    HoldingCtrl = false\n    PrevViewLock = 1\n    PreviousYawAmount = 0\n    PreviousPitchAmount = 0\n    msgText = \"empty\"\n    msgTimer = 3\n    targetGroundAltitude = nil -- So it can tell if one loaded or not\n    gearExtended = nil\n    LastEccentricity = 1\n    HoldAltitudeButtonModifier = 5\n    isBoosting = false -- Dodgin's Don't Die Rocket Govenor - Cruise Control Edition\n    distance = 0\n    brakeDistance, brakeTime = 0\n    maxBrakeDistance, maxBrakeTime = 0\n    hasGear = false\n    hasDB = false\n    hasSpaceRadar = false\n    hasAtmoRadar = false\n    damageMessage = [[]]\n    radarMessage = [[]]\n    LastOdometerOutput = \"\"\n    peris = 0\n    BrakeButtonHovered = false         \n    RetrogradeButtonHovered = false    \n    ProgradeButtonHovered = false\n    AutopilotButtonHovered = false\n    TurnBurnButtonHovered = false\n    FollowModeButtonHovered = false\n    AltitudeHoldButtonHovered = false\n    LandingButtonHovered = false\n    TakeoffButtonHovered = false\n    AutopilotTargetIndex = 0\n    AutopilotTargetName = \"None\"\n    AutopilotTargetPlanet = nil\n    AutopilotPlanetGravity = 0\n    UnitHidden = true\n    ResetAutoVars = false\n    totalDistanceTravelled = 0.0\n    totalDistanceTrip = 0\n    lastTravelTime = system.getTime()\n    totalMass = 0\n    core_altitude = core.getAltitude()\n    elementsID = core.getElementIdList() \n    -- Do not save these, they contain elementID's which can change.\n    atmoTanks = {}\n    spaceTanks = {}\n    rocketTanks = {}\n    eleTotalMaxHp = 0\n    flightTime = 0\n    totalFlightTime = 0\n\n    -- updateHud() variables\n    rgb = [[rgb(]] .. mfloor(PrimaryR+0.5) .. \",\" .. mfloor(PrimaryG+0.5) .. \",\" .. mfloor(PrimaryB+0.5) .. [[)]]\n    rgbdim = [[rgb(]] .. mfloor(PrimaryR *0.9 + 0.5) .. \",\" .. mfloor(PrimaryG * 0.9 + 0.5) .. \",\" .. mfloor(PrimaryB * 0.9 + 0.5) .. [[)]]\n    rgbdimmer = [[rgb(]] .. mfloor(PrimaryR *0.8 + 0.5) .. \",\" .. mfloor(PrimaryG * 0.8 + 0.5) .. \",\" .. mfloor(PrimaryB * 0.8 + 0.5) .. [[)]]\n    UpdateCount = 0\n    titlecolR = rgb\n    titlecol = rgb\n    titlecolS = rgb\n    fuelTimeLeftR = {}\n    fuelPercentR = {}\n    FuelUpdateDelay = mfloor(1/apTickRate)*2\n    fuelTimeLeftS = {}\n    fuelPercentS = {}\n    fuelTimeLeft = {}\n    fuelPercent = {}\n    updateTanks = false\n    honeyCombMass = 0\n    upAmount = 0\n\n    -- LOCAL VARIABLES, USERS DO NOT CHANGE\n    local AutopilotStrength = 1 -- How strongly autopilot tries to point at a target\n    local alignmentTolerance = 0.001 -- How closely it must align to a planet before accelerating to it\n    local ResolutionWidth = 2560\n    local ResolutionHeight = 1440\n    local ButtonBrakeWidth = 260             -- Size and positioning for brake button\n    local ButtonBrakeHeight = 50             -- Size and positioning for brake button\n    local ButtonBrakeX = ResolutionWidth/2 - ButtonBrakeWidth/2         -- Size and positioning for brake button\n    local ButtonBrakeY = ResolutionHeight/2 - ButtonBrakeHeight + 400   -- Size and positioning for brake button\n    local ButtonProgradeWidth = 260          -- Size and positioning for prograde button\n    local ButtonProgradeHeight = 50          -- Size and positioning for prograde button       \n    local ButtonProgradeX = ResolutionWidth/2 - ButtonProgradeWidth/2 - ButtonBrakeWidth - 50   -- Size and positioning for prograde button\n    local ButtonProgradeY = ResolutionHeight/2 - ButtonProgradeHeight + 380                     -- Size and positioning for prograde button\n    local ButtonRetrogradeWidth = 260        -- Size and positioning for retrograde button\n    local ButtonRetrogradeHeight = 50        -- Size and positioning for retrograde button       \n    local ButtonRetrogradeX = ResolutionWidth/2 - ButtonRetrogradeWidth/2 + ButtonBrakeWidth + 50   -- Size and positioning for retrograde button\n    local ButtonRetrogradeY = ResolutionHeight/2 - ButtonRetrogradeHeight + 380                     -- Size and positioning for retrograde button\n    local ButtonAutopilotWidth = 600 -- Size and positioning for autopilot button\n    local ButtonAutopilotHeight = 60 -- Size and positioning for autopilot button\n    local ButtonAutopilotX = ResolutionWidth/2 - ButtonAutopilotWidth/2\n    local ButtonAutopilotY = ResolutionHeight/2 - ButtonAutopilotHeight/2 - 400\n    local ButtonTurnBurnWidth = 300 -- Size and positioning for TurnBurn button\n    local ButtonTurnBurnHeight = 60 -- Size and positioning for TurnBurn button\n    local ButtonTurnBurnX = 10\n    local ButtonTurnBurnY = ResolutionHeight/2  - 300\n    local ButtonAltitudeHoldWidth = 300 -- Size and positioning for AltitudeHold button\n    local ButtonAltitudeHoldHeight = 60 -- Size and positioning for AltitudeHold button\n    local ButtonAltitudeHoldX = ButtonTurnBurnX + ButtonTurnBurnWidth + 20\n    local ButtonAltitudeHoldY = ButtonTurnBurnY\n    local ButtonLandingWidth = 300 -- Size and positioning for Landing button\n    local ButtonLandingHeight = 60 -- Size and positioning for Landing button\n    local ButtonLandingX = ButtonTurnBurnX\n    local ButtonLandingY = ButtonTurnBurnY + ButtonTurnBurnHeight + 20\n    local ButtonTakeoffWidth = 300 -- Size and positioning for Takeoff button\n    local ButtonTakeoffHeight = 60 -- Size and positioning for Takeoff button\n    local ButtonTakeoffX = ButtonTurnBurnX + ButtonTurnBurnWidth + 20\n    local ButtonTakeoffY = ButtonLandingY\n    local ButtonFollowModeWidth = 300 -- Size and positioning for FollowMode button\n    local ButtonFollowModeHeight = 60 -- Size and positioning for FollowMode button\n    local ButtonFollowModeX = ButtonTurnBurnX\n    local ButtonFollowModeY = ButtonTakeoffY + ButtonTakeoffHeight + 20\n    local minAtlasX = nil\n    local maxAtlasX = nil\n    local minAtlasY = nil\n    local maxAtlasY = nil\n    local valuesAreSet = false\n    local doubleCheck = false\n\n    -- VARIABLES TO BE SAVED GO HERE\n    SaveableVariables = \n    {\n        \"userControlScheme\", \n        \"AutopilotTargetOrbit\",\n        \"apTickRate\",\n        \"brakeToggle\",\n        \"freeLookToggle\",\n        \"turnAssist\",\n        \"PrimaryR\",\n        \"PrimaryG\",\n        \"PrimaryB\",\n        \"warmup\",\n        \"DeadZone\",\n        \"circleRad\",\n        \"MouseXSensitivity\",\n        \"MouseYSensitivity\",\n        \"MaxGameVelocity\",\n        \"showHud\",\n        \"autoRoll\",\n        \"pitchSpeedFactor\",\n        \"yawSpeedFactor\",\n        \"rollSpeedFactor\",\n        \"brakeSpeedFactor\",\n        \"brakeFlatFactor\",\n        \"autoRollFactor\",\n        \"turnAssistFactor\",\n        \"torqueFactor\",\n        \"AutoTakeoffAltitude\",\n        \"TargetHoverHeight\",\n        \"AutopilotInterplanetaryThrottle\",\n        \"hideHudOnToggleWidgets\",\n        \"DampingMultiplier\",\n        \"fuelTankOptimization\",\n        \"RemoteFreeze\",\n        \"speedChangeLarge\",\n        \"speedChangeSmall\",\n        \"brightHud\"\n    }\n    AutoVariables = \n    {\n        \"OldAutoRoll\",\n        \"hasGear\",\n        \"BrakeIsOn\",\n        \"RetrogradeIsOn\",             \n        \"ProgradeIsOn\",             \n        \"AutoBrake\",\n        \"Autopilot\",\n        \"FollowMode\",\n        \"TurnBurn\",\n        \"AltitudeHold\",\n        \"AutoLanding\",\n        \"AutoTakeoff\",\n        \"HoldAltitude\",\n        \"AutopilotAccelerating\",\n        \"AutopilotBraking\",\n        \"AutopilotCruising\", \n        \"AutopilotRealigned\",\n        \"AutopilotEndSpeed\",\n        \"AutopilotStatus\",\n        \"AutopilotPlanetGravity\",\n        \"PrevViewLock\",\n        \"AutopilotTargetName\",\n        \"AutopilotTargetPlanet\",\n        \"AutopilotTargetCoords\",\n        \"AutopilotTargetIndex\",\n        \"gearExtended\",\n        \"targetGroundAltitude\",\n        \"totalDistanceTravelled\",\n        \"honeyCombMass\",\n        \"totalFlightTime\"\n    }\n\n    -- BEGIN CONDITIONAL CHECKS DURING STARTUP\n    -- Load Saved Variables\n    if dbHud then\n        local hasKey = dbHud.hasKey\n        for k,v in pairs(SaveableVariables) do\n            if hasKey(v) then\n                local result = jdecode(dbHud.getStringValue(v))\n                if result ~= nil then\n                system.print(v..\" \"..dbHud.getStringValue(v))\n                _G[v] = result\n                    valuesAreSet = true\n                end\n            end\n        end\n        for k,v in pairs(AutoVariables) do\n            if hasKey(v) then\n                local result = jdecode(dbHud.getStringValue(v))\n                if result ~= nil then\n                system.print(v..\" \"..dbHud.getStringValue(v))\n                _G[v] = result\n                end\n            end\n        end\n        if valuesAreSet then\n            msgText = \"Loaded Saved Variables (see Lua Chat Tab for list)\"\n        else\n            msgText = \"No Saved Variables Found - Use Alt-7 to save your LUA parameters\"\n        end\n    else\n        msgText = \"No databank found\"\n    end\n    if(honeyCombMass == 0) then honeyCombMass = constructMass() - updateMass() end\n    for k in pairs(elementsID) do\n        local name = eleType(elementsID[k])\n        if (name == \"landing gear\") then \n            hasGear = true\n        end\n        eleTotalMaxHp = eleTotalMaxHp + eleMaxHp(elementsID[k])\n        if (name == \"atmospheric fuel-tank\" or name == \"space fuel-tank\" or name == \"rocket fuel-tank\" ) then\n            local hp = eleMaxHp(elementsID[k])\n            local mass = core.getElementMassById(elementsID[k])\n            local curMass = 0\n            local curTime = system.getTime()\n            if (name == \"atmospheric fuel-tank\") then \n                local vanillaMaxVolume = 400\n                local massEmpty = 35.03\n                if hp > 10000 then \n                    vanillaMaxVolume = 51200 -- volume in kg of L tank\n                    massEmpty = 5480\n                elseif hp > 1300 then\n                    vanillaMaxVolume =  6400 -- volume in kg of M\n                    massEmpty = 988.67\n                elseif hp > 150 then\n                    vanillaMaxVolume = 1600 --- volume in kg small\n                    massEmpty = 182.67\n                end\n                curMass = mass - massEmpty\n                if curMass > vanillaMaxVolume then \n                    vanillaMaxVolume = curMass\n                end\n                if fuelTankOptimization > 0 then \n                    vanillaMaxVolume = vanillaMaxVolume + (vanillaMaxVolume*fuelTankOptimization)\n                end\n                atmoTanks[#atmoTanks + 1] = {elementsID[k], core.getElementNameById(elementsID[k]), vanillaMaxVolume, massEmpty, curMass, curTime}\n            end\n            if (name == \"rocket fuel-tank\") then \n                local vanillaMaxVolume = 320\n                local massEmpty = 173.42\n                if hp > 65000 then \n                    vanillaMaxVolume = 40000 -- volume in kg of L tank\n                    massEmpty = 25740\n                elseif hp > 6000 then\n                    vanillaMaxVolume =  5120 -- volume in kg of M\n                    massEmpty = 4720\n                elseif hp > 700 then\n                    vanillaMaxVolume = 640 --- volume in kg small\n                    massEmpty = 886.72\n                end\n                curMass = mass - massEmpty\n                if curMass > vanillaMaxVolume then \n                    vanillaMaxVolume = curMass\n                end\n                if fuelTankOptimization > 0 then \n                    vanillaMaxVolume = vanillaMaxVolume + (vanillaMaxVolume*fuelTankOptimization)\n                end\n               rocketTanks[#rocketTanks + 1] = {elementsID[k], core.getElementNameById(elementsID[k]), vanillaMaxVolume, massEmpty, curMass, curTime}\n            end\n            if (name == \"space fuel-tank\") then \n                local vanillaMaxVolume = 2400\n                local massEmpty = 187.67\n                if hp > 10000 then \n                    vanillaMaxVolume = 76800 -- volume in kg of L tank\n                    massEmpty = 5480\n                elseif hp > 1300 then\n                    vanillaMaxVolume =  9600 -- volume in kg of M\n                    massEmpty = 988.67\n                end\n                curMass = mass - massEmpty\n                if curMass > vanillaMaxVolume then \n                    vanillaMaxVolume = curMass\n                end\n                if fuelTankOptimization > 0 then \n                    vanillaMaxVolume = vanillaMaxVolume + (vanillaMaxVolume*fuelTankOptimization)\n                end\n                spaceTanks[#spaceTanks + 1] = {elementsID[k], core.getElementNameById(elementsID[k]), vanillaMaxVolume, massEmpty, curMass, curTime}\n            end\n        end\n    end\n\n    if gyro ~= nil then\n        GyroIsOn = gyro.getState() == 1\n    end\n\n    if userControlScheme ~= \"Keyboard\" then\n        system.lockView(1)\n    else\n        system.lockView(0)\n    end\n    if atmosphere() > 0 then\n        BrakeIsOn = true\n    end  \n    if radar_1 then\n        if eleType(radar_1.getId()) == \"Space Radar\" then\n            hasSpaceRadar = true\n        else\n            hasAtmoRadar = true\n        end\n    end\n    -- Close door and retract ramp if available\n    if door then\n        for _,v in pairs(door) do\n            v.deactivate()\n        end\n    end\n    if forcefield then\n        for _,v in pairs(forcefield) do\n            v.deactivate()\n        end\n    end\n    _autoconf.displayCategoryPanel(weapon, weapon_size, \"Weapons\", \"weapon\", true)\n    if antigrav ~= nil then antigrav.show() end\n    if warpdrive ~= nil then warpdrive.show() end\n    -- unfreeze the player if he is remote controlling the construct\n    if Nav.control.isRemoteControlled() == 1 and RemoteFreeze then\n        system.freeze(1)\n    else\n        system.freeze(0)\n    end\n    if targetGroundAltitude ~= nil then\n        Nav.axisCommandManager:setTargetGroundAltitude(targetGroundAltitude)\n    end\n    if hasGear then\n        if gearExtended == nil then\n            gearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean\n            if gearExtended then\n                Nav.control.extendLandingGears()\n            else\n                Nav.control.retractLandingGears()\n            end\n        end\n        if targetGroundAltitude == nil then\n            if gearExtended then\n                Nav.axisCommandManager:setTargetGroundAltitude(0)\n            else\n                Nav.axisCommandManager:setTargetGroundAltitude(TargetHoverHeight)\n            end\n        end\n    elseif targetGroundAltitude == nil then\n        if atmosphere() == 0 then\n            gearExtended = false\n            Nav.axisCommandManager:setTargetGroundAltitude(TargetHoverHeight)\n        else\n            gearExtended = true -- Show warning message and set behavior\n            Nav.axisCommandManager:setTargetGroundAltitude(0)\n        end\n    end\n    if atmosphere() > 0 and not dbHud and (gearExtended or not hasGear) then\n        BrakeIsOn = true\n    end\n\n    unit.hide()\n    unit.setTimer(\"apTick\", apTickRate)\n    unit.setTimer(\"oneSecond\", 1)\n\n    system.showScreen(1)\n\n    InAtmo = (atmosphere() > 0)\n    Animating = false\n    Animated = false\n\n    -- That was a lot of work with dirty strings and json.  Clean up\n    collectgarbage(\"collect\")",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": -1
      },
      "key": 3
    },
    {
      "code": "_autoconf.hideCategoryPanels()\nif antigrav ~= nil then antigrav.hide() end\nif warpdrive ~= nil then warpdrive.hide() end\ncore.hide()\nNav.control.switchOffHeadlights()\n-- Open door and extend ramp if available\nlocal atmo = unit.getAtmosphereDensity()\nif door and (atmo > 0 or (atmo == 0 and core_altitude < 10000)) then\nfor _,v in pairs(door) do\nv.activate()\nend\nend\nif forcefield and (atmo > 0 or (atmo == 0 and core_altitude < 10000)) then\nfor _,v in pairs(forcefield) do\nv.activate()\nend\nend\n-- Save autovariables\nif dbHud then\nif not ResetAutoVars then\nfor k,v in pairs(AutoVariables) do\ndbHud.setStringValue(v,json.encode(_G[v]))\nend\nend\nend\nif button then\nbutton.activate()\nend",
      "filter": {
        "args": [],
        "signature": "stop()",
        "slotKey": -1
      },
      "key": 4
    },
    {
      "code": "Animated = true\nAnimating = false\nsimulatedX = 0\nsimulatedY = 0\nunit.stopTimer(\"animateTick\")",
      "filter": {
        "args": [
          {
            "value": "animateTick"
          }
        ],
        "signature": "tick([animateTick])",
        "slotKey": -1
      },
      "key": 5
    },
    {
      "code": "    -- Timer for evaluation every 1 second\n    checkDamage()\n    updateDistance()\n    if (radar_1 and #radar_1.getEntries() > 0) then\n        local target\n        target = radar_1.getData():find('identifiedConstructs\":%[%]')\n        if target == nil and perisPanelID == nil then\n            peris = 1\n            ToggleRadarPanel()\n        end\n        if target ~= nil and perisPanelID ~= nil then\n            ToggleRadarPanel()\n        end\n        if radarPanelID == nil then\n            ToggleRadarPanel()\n        end\n\n        local radarContacts = #radar_1.getEntries()\n        radarMessage = string.format([[<g class=\"text\"><g font-size=14><text x=\"1770\" y=\"330\" text-anchor=\"middle\" style=\"fill:%s\">Radar: %i contacts</text></g></g>]],rgbO,radarContacts)\n    elseif radar_1 then\n        local data\n        data = radar_1.getData():find('worksInEnvironment\":false')\n        if data then\n            radarMessage =  string.format([[<g class=\"text\"><g font-size=14><text x=\"1770\" y=\"330\" text-anchor=\"middle\" style=\"fill:%s\">Radar: Jammed</text></g></g>]],rgbO)\n        else\n            radarMessage =  string.format([[<g class=\"text\"><g font-size=14><text x=\"1770\" y=\"330\" text-anchor=\"middle\" style=\"fill:%s\">Radar: No Contacts</text></g></g>]],rgbO)\n        end\n        if radarPanelID ~= nil then\n            peris = 0\n            ToggleRadarPanel()\n        end\n    end \n\n    -- Update odometer output string\n    local newContent = {}\n    local flightStyle = GetFlightStyle()\n    DrawOdometer(newContent, totalDistanceTrip, totalDistanceTravelled, flightStyle, flightTime)       \n    LastOdometerOutput = table.concat(newContent, \"\")",
      "filter": {
        "args": [
          {
            "value": "oneSecond"
          }
        ],
        "signature": "tick([oneSecond])",
        "slotKey": -1
      },
      "key": 6
    },
    {
      "code": "-- This is used to clear a message on screen after a short period of time and then stop itself\nDisplayMessage(newContent, \"empty\")\nmsgText = \"empty\"\nunit.stopTimer(\"msgTick\")\nmsgTimer = 3",
      "filter": {
        "args": [
          {
            "value": "msgTick"
          }
        ],
        "signature": "tick([msgTick])",
        "slotKey": -1
      },
      "key": 7
    },
    {
      "code": "    -- NO USER CHANGES\n    yawInput2 = 0\n    rollInput2 = 0\n    pitchInput2 = 0\n    LastApsDiff = -1\n    local velocity = vec3(core.getWorldVelocity())\n    local velMag = vec3(velocity):len()\n    local sys = galaxyReference[0]\n    planet = sys:closestBody(core.getConstructWorldPos())\n    kepPlanet = Kep(planet)\n    orbit = kepPlanet:orbitalParameters(core.getConstructWorldPos(), velocity)\n    local deltaX = system.getMouseDeltaX()\n    local deltaY = system.getMouseDeltaY()\n    targetGroundAltitude = Nav:getTargetGroundAltitude()\n    local TrajectoryAlignmentStrength = 0.002 -- How strongly AP tries to align your velocity vector to the target when not in orbit\n    if BrakeIsOn then\n        brakeInput = 1\n    else\n        brakeInput = 0\n    end\n    core_altitude = core.getAltitude()\n    if core_altitude == 0 then\n        core_altitude = (vec3(core.getConstructWorldPos())-planet.center):len()-planet.radius\n    end\n\n    if AutopilotTargetName ~= \"None\" then\n\n        ShowInterplanetaryPanel()\n        system.updateData(interplanetaryHeaderText, '{\"label\": \"Target\", \"value\": \"' .. AutopilotTargetName .. '\", \"unit\":\"\"}')\n        travelTime = GetAutopilotTravelTime() -- This also sets AutopilotDistance so we don't have to calc it again\n        distance = AutopilotDistance\n        if not TurnBurn then \n            brakeDistance, brakeTime = GetAutopilotBrakeDistanceAndTime(velMag)\n            maxBrakeDistance, maxBrakeTime = GetAutopilotBrakeDistanceAndTime(MaxGameVelocity)\n        else\n            brakeDistance, brakeTime = GetAutopilotTBBrakeDistanceAndTime(velMag)\n            maxBrakeDistance, maxBrakeTime = GetAutopilotTBBrakeDistanceAndTime(MaxGameVelocity)\n        end\n        system.updateData(widgetDistanceText, '{\"label\": \"Distance\", \"value\": \"' .. getDistanceDisplayString(distance) .. '\", \"unit\":\"\"}')\n        system.updateData(widgetTravelTimeText, '{\"label\": \"Travel Time\", \"value\": \"' .. FormatTimeString(travelTime) .. '\", \"unit\":\"\"}')\n        system.updateData(widgetCurBrakeDistanceText, '{\"label\": \"Cur Brake Distance\", \"value\": \"' .. getDistanceDisplayString(brakeDistance) .. '\", \"unit\":\"\"}')\n        system.updateData(widgetCurBrakeTimeText, '{\"label\": \"Cur Brake Time\", \"value\": \"' .. FormatTimeString(brakeTime) .. '\", \"unit\":\"\"}')\n        system.updateData(widgetMaxBrakeDistanceText, '{\"label\": \"Max Brake Distance\", \"value\": \"' .. getDistanceDisplayString(maxBrakeDistance) .. '\", \"unit\":\"\"}')\n        system.updateData(widgetMaxBrakeTimeText, '{\"label\": \"Max Brake Time\", \"value\": \"' .. FormatTimeString(maxBrakeTime) .. '\", \"unit\":\"\"}')\n        if unit.getAtmosphereDensity() > 0 and not InAtmo then\n            system.removeDataFromWidget(widgetMaxBrakeTimeText, widgetMaxBrakeTime)\n            system.removeDataFromWidget(widgetMaxBrakeDistanceText, widgetMaxBrakeDistance)\n            system.removeDataFromWidget(widgetCurBrakeTimeText, widgetCurBrakeTime)\n            system.removeDataFromWidget(widgetCurBrakeDistanceText, widgetCurBrakeDistance)\n            system.removeDataFromWidget(widgetTrajectoryAltitudeText, widgetTrajectoryAltitude)\n            InAtmo = true\n        elseif unit.getAtmosphereDensity() == 0 and InAtmo then\n            system.addDataToWidget(widgetMaxBrakeTimeText, widgetMaxBrakeTime)\n            system.addDataToWidget(widgetMaxBrakeDistanceText, widgetMaxBrakeDistance)\n            system.addDataToWidget(widgetCurBrakeTimeText, widgetCurBrakeTime)\n            system.addDataToWidget(widgetCurBrakeDistanceText, widgetCurBrakeDistance)\n            system.addDataToWidget(widgetTrajectoryAltitudeText, widgetTrajectoryAltitude)\n            InAtmo = false\n        end\n    else\n        HideInterplanetaryPanel()\n    end\n\n    local newContent = {}\n    if showHud then\n        updateHud(newContent) -- sets up Content for us\n    else\n        newContent[#newContent + 1] = [[<head>\n            <style>\n                body {margin: 0}\n                svg {display:block; position: absolute; top:0; left:0}\n                text {font-family:Montserrat;font-weight:bold}\n            </style>\n            <body>\n                <svg height=\"100vh\" width=\"100vw\" viewbox=\"0 0 1920 1080\">]]\n        DisplayOrbit(newContent)\n        DrawWarnings(newContent)\n    end\n    newContent[#newContent + 1] = [[<svg width=\"100vw\" height=\"100vh\" style=\"position:absolute;top:0;left:0\"  viewBox=\"0 0 2560 1440\">]]\n    if msgText ~= \"empty\" then \n        DisplayMessage(newContent, msgText)\n    end\n    if Nav.control.isRemoteControlled() == 0 and userControlScheme == \"Virtual Joystick\" then\n        DrawDeadZone(newContent)\n    end\n\n    if Nav.control.isRemoteControlled() == 1 and screen_1 and screen_1.getMouseY() ~= -1 then\n        simulatedX = screen_1.getMouseX()*2560\n        simulatedY = screen_1.getMouseY()*1440\n        SetButtonContains()\n        DrawButtons(newContent)\n        if screen_1.getMouseState() == 1 then\n            CheckButtons()\n        end\n        newContent[#newContent + 1] = string.format(\"<circle stroke='white' cx='calc(50%% + %fpx)' cy='calc(50%% + %fpx)' r='5'/>\", simulatedX, simulatedY)\n    elseif system.isViewLocked() == 0 then\n        if Nav.control.isRemoteControlled() == 1 and HoldingCtrl then\n            if not Animating then\n                simulatedX = simulatedX + deltaX\n                simulatedY = simulatedY + deltaY\n            end\n            SetButtonContains()\n            DrawButtons(newContent)\n\n            -- If they're remote, it's kinda weird to be 'looking' everywhere while you use the mouse\n            -- We need to add a body with a background color\n            if not Animating and not Animated then\n                local collapsedContent = table.concat(newContent, \"\")\n                newContent = {}\n                newContent[#newContent + 1] = \"<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%' height='100%' position='absolute' top='0' left='0'><rect width='100%' height='100%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%' height='50%' style='position:absolute;top:30%;left:25%' viewbox='0 0 1920 1080'>\"\n                newContent[#newContent + 1] = GalaxyMapHTML\n                newContent[#newContent + 1] = collapsedContent\n                newContent[#newContent + 1] = \"</body>\"\n                Animating = true\n                newContent[#newContent + 1] = [[</svg></body>]] -- Uh what.. okay...\n                unit.setTimer(\"animateTick\",0.5)\n                local content = table.concat(newContent, \"\")\n                system.setScreen(content)\n            elseif Animated then\n                local collapsedContent = table.concat(newContent, \"\")\n                newContent = {}\n                newContent[#newContent + 1] = \"<body style='background-color:rgb(6,5,26)'><svg width='50%' height='50%' style='position:absolute;top:30%;left:25%' viewbox='0 0 1920 1080'>\"\n                newContent[#newContent + 1] = GalaxyMapHTML\n                newContent[#newContent + 1] = collapsedContent\n                newContent[#newContent + 1] = \"</body>\"\n            end\n            \n            if not Animating then\n                newContent[#newContent + 1] = string.format(\"<circle stroke='white' cx='calc(50%% + %fpx)' cy='calc(50%% + %fpx)' r='5'/>\", simulatedX, simulatedY)\n            end\n        else\n            CheckButtons()\n            simulatedX = 0\n            simulatedY = 0 -- Reset after they do view things, and don't keep sending inputs while unlocked view\n            -- Except of course autopilot, which is later.\n        end\n    else\n        simulatedX = simulatedX + deltaX\n        simulatedY = simulatedY + deltaY\n        distance = math.sqrt(simulatedX*simulatedX + simulatedY*simulatedY)\n        if not HoldingCtrl and Nav.control.isRemoteControlled() == 0 then -- Draw deadzone circle if it's navigating\n            if userControlScheme == \"Virtual Joystick\" then -- Virtual Joystick\n                -- Do navigation things\n                \n                if simulatedX > 0 and simulatedX > DeadZone then\n                    yawInput2 = yawInput2 - (simulatedX - DeadZone) * MouseXSensitivity\n                elseif simulatedX < 0 and simulatedX < (DeadZone * -1) then\n                    yawInput2 = yawInput2 - (simulatedX + DeadZone) * MouseXSensitivity\n                else\n                    yawInput2 = 0\n                end\n            \n                if simulatedY > 0 and simulatedY > DeadZone then\n                    pitchInput2 = pitchInput2 - (simulatedY - DeadZone) * MouseYSensitivity\n                elseif simulatedY < 0 and simulatedY < (DeadZone * -1) then\n                    pitchInput2 = pitchInput2 - (simulatedY + DeadZone) * MouseYSensitivity\n                else\n                     pitchInput2 = 0\n                end\n            elseif userControlScheme == \"Mouse\" then -- Mouse Direct\n                simulatedX = 0\n                simulatedY = 0\n                --pitchInput2 = pitchInput2 - deltaY * mousePitchFactor\n                --yawInput2 = yawInput2 - deltaX * mouseYawFactor\n                -- So... this is weird.  \n                -- It's doing some odd things and giving us some weird values. \n                \n                -- utils.smoothstep(progress, low, high)*2-1\n                pitchInput2 = (-utils.smoothstep(deltaY, -100, 100) + 0.5)*2*mousePitchFactor\n                yawInput2 = (-utils.smoothstep(deltaX, -100, 100) + 0.5)*2*mouseYawFactor\n            else -- Keyboard mode\n                simulatedX = 0\n                simulatedY = 0\n                -- Don't touch anything, they have it with kb only.  \n            end\n\n\n\n            -- Right so.  We can't detect a mouse click.  That's stupid.  \n            -- We have two options.  1. Use mouse wheel movement as a click, or 2. If you're hovered over a button and let go of Ctrl, it's a click\n            -- I think 2 is a much smoother solution.  Even if we later want to have them input some coords\n            -- We'd have to hook 0-9 in their events, and they'd have to point at the target, so it wouldn't be while this screen is open\n            \n            -- What that means is, if we get here, check our hovers.  If one of them is active, trigger the thing and deactivate the hover\n            CheckButtons()\n            \n            \n            if distance > DeadZone then -- Draw a line to the cursor from the screen center\n                -- Note that because SVG lines fucking suck, we have to do a translate and they can't use calc in their params\n                DrawCursorLine(newContent)\n            end\n        else\n            -- Ctrl is being held, draw buttons.\n            -- Brake toggle, face prograde, face retrograde (for now)\n            -- We've got some vars setup in Start for them to make this easier to work with\n            SetButtonContains()\n            DrawButtons(newContent)\n            \n        end\n        -- Cursor always on top, draw it last\n        newContent[#newContent + 1] = string.format(\"<circle stroke='white' cx='calc(50%% + %fpx)' cy='calc(50%% + %fpx)' r='5'/>\", simulatedX, simulatedY)\n\n    end\n    newContent[#newContent + 1] = [[</svg></body>]]\n    local content = table.concat(newContent, \"\")\n    if content ~= LastContent then\n        --if Nav.control.isRemoteControlled() == 1 and screen_1 then -- Once the screens are fixed we can do this.\n        --    screen_1.setHTML(content) -- But also this is disgusting and the resolution's terrible.  We're doing something wrong.\n        --else\n        if not Animating then\n            system.setScreen(content)\n        end\n        --end\n    end\n    LastContent = content\n    if AutoBrake and AutopilotTargetPlanetName ~= \"None\" and (vec3(core.getConstructWorldPos())-vec3(AutopilotTargetPlanet.center)):len() <= brakeDistance then\n        brakeInput = 1\n        if planet.name == AutopilotTargetPlanet.name and orbit.apoapsis ~= nil and orbit.eccentricity < 1 then\n                -- We're increasing eccentricity by braking, time to stop\n                brakeInput = 0\n                AutoBrake = false\n        end\n    end\n    if ProgradeIsOn then \n        if velMag > MinAutopilotSpeed then -- Help with div by 0 errors and careening into terrain at low speed\n                AlignToWorldVector(vec3(velocity))\n        end\n    end\n    if RetrogradeIsOn then \n        if velMag > MinAutopilotSpeed then -- Help with div by 0 errors and careening into terrain at low speed\n                AlignToWorldVector(-(vec3(velocity)))\n        end\n    end\n    if Autopilot and unit.getAtmosphereDensity() == 0 then\n        -- Planetary autopilot engaged, we are out of atmo, and it has a target\n        -- Do it.  \n        -- And tbh we should calc the brakeDistance live too, and of course it's also in meters\n        local brakeDistance, brakeTime\n        if not TurnBurn then\n            brakeDistance, brakeTime = GetAutopilotBrakeDistanceAndTime(velMag)\n        else\n            brakeDistance, brakeTime = GetAutopilotTBBrakeDistanceAndTime(velMag)\n        end\n        brakeDistance = brakeDistance \n        brakeTime = brakeTime -- * 1.05 -- Padding?\n        -- Maybe instead of pointing at our vector, we point at our vector + how far off our velocity vector is\n        -- This is gonna be hard to get the negatives right.\n        -- If we're still in orbit, don't do anything, that velocity will suck\n        local targetCoords = AutopilotTargetCoords\n        if orbit.apoapsis == nil and velMag > 300 and AutopilotAccelerating then\n            -- Get the angle between forward and velocity\n            -- Get the magnitude for each of yaw and pitch\n            -- Consider a right triangle, with side a being distance to our target\n            -- get side b, where have the angle.  Do this once for each of yaw and pitch\n            -- The result of each of those would then be multiplied by something to make them vectors...\n            \n            \n            -- Okay another idea.\n            -- Normalize forward and velocity, then get the ratio of normvelocity:velocity\n            -- And scale forward back up by that amount.  Then take forward-velocity, the \n            \n            \n            -- No no.\n            -- Okay so, first, when we realign, we store shipright and shipup, just for this\n            -- Get the difference between ship forward and normalized worldvel\n            -- Get the components in each of the stored shipright and shipup directions\n            -- Get the ratio of velocity to normalized velocity and scale up that component (Hey this is just velmag btw)\n            -- Add that component * shipright or shipup\n            local velVectorOffset = (vec3(AutopilotTargetCoords) - vec3(core.getConstructWorldPos())):normalize() - vec3(velocity):normalize()\n            local pitchComponent = getMagnitudeInDirection(velVectorOffset, AutopilotShipUp)\n            local yawComponent = getMagnitudeInDirection(velVectorOffset, AutopilotShipRight)\n            local leftAmount = -yawComponent * AutopilotDistance * velMag*TrajectoryAlignmentStrength\n            local downAmount = -pitchComponent * AutopilotDistance * velMag*TrajectoryAlignmentStrength\n            targetCoords = AutopilotTargetCoords + (-leftAmount * vec3(AutopilotShipRight)) + (-downAmount * vec3(AutopilotShipUp))\n        end\n        -- If we're here, sadly, we really need to calc the distance every update (or tick)\n        AutopilotDistance = (vec3(targetCoords) - vec3(core.getConstructWorldPos())):len()\n        system.updateData(widgetDistanceText, '{\"label\": \"Distance\", \"value\": \"' .. getDistanceDisplayString(AutopilotDistance) .. '\", \"unit\":\"\"}')\n        local aligned = true  -- It shouldn't be used if the following condition isn't met, but just in case\n            \n        local projectedAltitude = (AutopilotTargetPlanet.center - (vec3(core.getConstructWorldPos()) + (vec3(velocity):normalize() * AutopilotDistance))):len() - AutopilotTargetPlanet.radius\n        system.updateData(widgetTrajectoryAltitudeText, '{\"label\": \"Projected Altitude\", \"value\": \"' .. getDistanceDisplayString(projectedAltitude) .. '\", \"unit\":\"\"}')\n\n        if not AutopilotCruising and not AutopilotBraking then\n            aligned = AlignToWorldVector((targetCoords-vec3(core.getConstructWorldPos())):normalize())\n        elseif TurnBurn then\n            aligned = AlignToWorldVector(-vec3(velocity):normalize())\n        end\n        if AutopilotAccelerating then\n            if not aligned then\n                AutopilotStatus = \"Adjusting Trajectory\"\n            else\n                AutopilotStatus = \"Accelerating\"\n            end\n            \n            if vec3(core.getVelocity()):len() >= MaxGameVelocity then -- This is 29999 kph\n                AutopilotAccelerating = false\n                AutopilotStatus = \"Cruising\"\n                AutopilotCruising = true\n                Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 0)\n            end\n            -- Check if accel needs to stop for braking\n            if AutopilotDistance <= brakeDistance then\n                AutopilotAccelerating = false\n                AutopilotStatus = \"Braking\"\n                AutopilotBraking = true\n                Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 0)\n            end\n        elseif AutopilotBraking then\n            BrakeIsOn = true\n            brakeInput = 1\n            if TurnBurn then\n                Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100) -- This stays 100 to not mess up our calculations\n            end\n            -- Check if an orbit has been established and cut brakes and disable autopilot if so\n            \n            -- We'll try <0.9 instead of <1 so that we don't end up in a barely-orbit where touching the controls will make it an escape orbit\n            -- Though we could probably keep going until it starts getting more eccentric, so we'd maybe have a circular orbit\n            \n            if orbit.periapsis ~= nil and orbit.eccentricity < 1 then\n                AutopilotStatus = \"Circularizing\"\n                -- Keep going until the apoapsis and periapsis start getting further apart\n                -- Rather than: orbit.periapsis ~= nil and orbit.periapsis.altitude < ((vec3(planet.center) - vec3(core.getConstructWorldPos())):len() - planet.radius)-1000\n                --local apsDiff = math.abs(orbit.apoapsis.altitude - orbit.periapsis.altitude)\n                --if LastApsDiff ~= -1 and apsDiff > LastApsDiff then \n                if orbit.eccentricity > LastEccentricity or (orbit.apoapsis.altitude < AutopilotTargetOrbit and orbit.periapsis.altitude < AutopilotTargetOrbit) then\n                    --LastApsDiff = -1\n                    BrakeIsOn = false\n                    AutopilotBraking = false\n                    Autopilot = false\n                    AutopilotStatus = \"Aligning\" -- Disable autopilot and reset\n                    -- TODO: This is being added to newContent *after* we already drew the screen, so it'll never get displayed\n                    DisplayMessage(newContent, \"Autopilot completed, orbit established\")\n                    brakeInput = 0\n                    Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 0)\n                end\n                LastApsDiff = apsDiff\n            end\n        elseif AutopilotCruising then\n            if AutopilotDistance <= brakeDistance then\n                AutopilotAccelerating = false\n                AutopilotStatus = \"Braking\"\n                AutopilotBraking = true\n            end\n        else\n            -- It's engaged but hasn't started accelerating yet.\n            if aligned then\n                    -- Re-align to 200km from our aligned right                    \n                    if not AutopilotRealigned then -- Removed radius from this because it makes our readouts look inaccurate?\n                        AutopilotTargetCoords = vec3(AutopilotTargetPlanet.center) + ((AutopilotTargetOrbit + AutopilotTargetPlanet.radius) * vec3(core.getConstructWorldOrientationRight()))\n                        AutopilotRealigned = true\n                        AutopilotShipUp = core.getConstructWorldOrientationUp()\n                        AutopilotShipRight = core.getConstructWorldOrientationRight()\n                    elseif aligned then\n                        AutopilotAccelerating = true\n                        AutopilotStatus = \"Accelerating\"\n                        -- Set throttle to max\n                        Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, AutopilotInterplanetaryThrottle)\n                end\n            end\n            -- If it's not aligned yet, don't try to burn yet.\n        end\n    end\n    if FollowMode then\n        -- User is assumed to be outside the construct\n        autoRoll = true -- Let Nav handle that while we're here\n        local targetPitch = 0\n        -- Keep brake engaged at all times unless: \n            -- Ship is aligned with the target on yaw (roll and pitch are locked to 0)\n            -- and ship's speed is below like 5-10m/s\n        local pos = vec3(core.getConstructWorldPos()) + vec3(unit.getMasterPlayerRelativePosition()) -- Is this related to core forward or nah?\n        local distancePos = (pos-vec3(core.getConstructWorldPos()))\n        --local distance = distancePos:len()\n        -- Distance needs to be calculated using only construct forward and right\n        local distanceForward = vec3(distancePos):project_on(vec3(core.getConstructWorldOrientationForward())):len()\n        local distanceRight = vec3(distancePos):project_on(vec3(core.getConstructWorldOrientationRight())):len()\n        --local distanceDown = vec3(distancePos):project_on(-vec3(core.getConstructWorldOrientationRight())):len()\n        local distance = math.sqrt(distanceForward*distanceForward+distanceRight*distanceRight)\n        AlignToWorldVector(distancePos:normalize())\n        local targetDistance = 40\n        --local onShip = false\n        --if distanceDown < 1 then \n        --    onShip = true\n        --end\n        local nearby = (distance < targetDistance)\n        local maxSpeed = 100 -- Over 300kph max, but, it scales down as it approaches\n        if onShip then\n            maxSpeed = 300\n        end\n        local targetSpeed = utils.clamp((distance-targetDistance)/2,10,maxSpeed)\n        pitchInput2 = 0\n        local aligned = (math.abs(yawInput2) < 0.1)\n        if (aligned and velMag < targetSpeed and not nearby) then -- or (not BrakeIsOn and onShip) then\n            --if not onShip then -- Don't mess with brake if they're on ship\n                BrakeIsOn = false\n            --end\n            targetPitch = -10\n        else\n            --if not onShip then\n                BrakeIsOn = true\n            --end\n            targetPitch = 0\n        end\n        local constrF = vec3(core.getConstructWorldOrientationForward())\n        local constrR = vec3(core.getConstructWorldOrientationRight())\n        local worldV = vec3(core.getWorldVertical())\n        local pitch = getPitch(worldV, constrF, constrR)\n        local autoPitchThreshold = 1.0\n        -- Copied from autoroll let's hope this is how a PID works... \n        if math.abs(targetPitch - pitch) > autoPitchThreshold then\n            if (pitchPID == nil) then\n                pitchPID = pid.new(2 * 0.01, 0, 2 * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n            end\n            pitchPID:inject(targetPitch - pitch)\n            local autoPitchInput = pitchPID:get()\n\n            pitchInput2 = autoPitchInput\n        end\n    end\n    if AltitudeHold then\n        -- HoldAltitude is the alt we want to hold at\n        local altitude = core_altitude\n        -- Dampen this.\n        local altDiff = HoldAltitude - altitude\n        local MaxPitch = 20\n        -- This may be better to smooth evenly regardless of HoldAltitude.  Let's say, 2km scaling?  Should be very smooth for atmo\n        -- Even better if we smooth based on their velocity\n        local minmax = 500 + velMag\n        local targetPitch = (utils.smoothstep(altDiff, -minmax, minmax) - 0.5)*2*MaxPitch \n        -- The clamp should now be redundant\n        --local targetPitch = utils.clamp(altDiff,-20,20) -- Clamp to reasonable values\n        -- Align it prograde but keep whatever pitch inputs they gave us before, and ignore pitch input from alignment.\n        -- So, you know, just yaw.\n        local oldInput = pitchInput2\n        if velMag > MinAutopilotSpeed then\n            AlignToWorldVector(vec3(velocity))\n        end\n        pitchInput2 = oldInput\n          \n        if AutoLanding then\n            targetPitch = -10 -- Some flat, easy value.\n            local groundDistance\n            if Nav.axisCommandManager:getAxisCommandType(0) == 1 then\n                Nav.control.cancelCurrentControlMasterMode()\n            end\n            Nav.axisCommandManager:setTargetGroundAltitude(500)\n            Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(500)\n            if vBooster then\n                groundDistance = vBooster.distance()\n            elseif hover then\n                groundDistance = hover.distance()\n            end\n            if groundDistance > -1 then\n                upAmount = 1\n                targetPitch = 10\n                BrakeIsOn = true\n                if velMag < 20 then\n                    targetPitch = 0\n                end\n                if velMag < 1 then\n                    AutoLanding = false\n                    AltitudeHold = false\n                    gearExtended = true\n                    Nav.control.extendLandingGears()\n                    Nav.axisCommandManager:setTargetGroundAltitude(0)\n                    upAmount = 0\n                end\n            end\n        elseif AutoTakeoff then\n            if targetPitch < 10 then\n                AutoTakeoff = false -- No longer in ascent\n            end\n        end\n        local constrF = vec3(core.getConstructWorldOrientationForward())\n        local constrR = vec3(core.getConstructWorldOrientationRight())\n        local worldV = vec3(core.getWorldVertical())\n        local pitch = getPitch(worldV, constrF, constrR)\n        local autoPitchThreshold = 0.1\n        -- Copied from autoroll let's hope this is how a PID works... \n        if math.abs(targetPitch - pitch) > autoPitchThreshold then\n            if (pitchPID == nil) then -- Changed from 2 to 8 to tighten it up around the target\n                pitchPID = pid.new(8 * 0.01, 0, 8 * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n            end\n            pitchPID:inject(targetPitch - pitch)\n            local autoPitchInput = pitchPID:get()\n            pitchInput2 = pitchInput2 + autoPitchInput\n        end\n    end\n    LastEccentricity = orbit.eccentricity",
      "filter": {
        "args": [
          {
            "value": "apTick"
          }
        ],
        "signature": "tick([apTick])",
        "slotKey": -1
      },
      "key": 8
    },
    {
      "code": "-- !DU: main\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": -2
      },
      "key": 9
    },
    {
      "code": "toggleFollowMode()",
      "filter": {
        "args": [
          {
            "value": "option8"
          }
        ],
        "signature": "actionStart([option8])",
        "slotKey": -2
      },
      "key": 10
    },
    {
      "code": "saveVariables()",
      "filter": {
        "args": [
          {
            "value": "option7"
          }
        ],
        "signature": "actionStart([option7])",
        "slotKey": -2
      },
      "key": 11
    },
    {
      "code": "ToggleAltitudeHold()",
      "filter": {
        "args": [
          {
            "value": "option6"
          }
        ],
        "signature": "actionStart([option6])",
        "slotKey": -2
      },
      "key": 12
    },
    {
      "code": "ToggleTurnBurn()",
      "filter": {
        "args": [
          {
            "value": "option5"
          }
        ],
        "signature": "actionStart([option5])",
        "slotKey": -2
      },
      "key": 13
    },
    {
      "code": "AutopilotToggle()",
      "filter": {
        "args": [
          {
            "value": "option4"
          }
        ],
        "signature": "actionStart([option4])",
        "slotKey": -2
      },
      "key": 14
    },
    {
      "code": "if not brakeToggle then\nif BrakeIsOn then\nBrakeToggle()\nelse\nBrakeIsOn = false -- Should never happen\nend\nend",
      "filter": {
        "args": [
          {
            "value": "brake"
          }
        ],
        "signature": "actionStop([brake])",
        "slotKey": -2
      },
      "key": 15
    },
    {
      "code": "if brakeToggle then\nBrakeToggle()\nelseif not BrakeIsOn then\nBrakeToggle() -- Trigger the cancellations\nelse\nBrakeIsOn = true -- Should never happen\nend",
      "filter": {
        "args": [
          {
            "value": "brake"
          }
        ],
        "signature": "actionStart([brake])",
        "slotKey": -2
      },
      "key": 16
    },
    {
      "code": "if warpdrive ~= nil then warpdrive.activateWarp() end",
      "filter": {
        "args": [
          {
            "value": "warp"
          }
        ],
        "signature": "actionStart([warp])",
        "slotKey": -2
      },
      "key": 17
    },
    {
      "code": "if antigrav ~= nil then\nantigrav.toggle()\nend",
      "filter": {
        "args": [
          {
            "value": "antigravity"
          }
        ],
        "signature": "actionStart([antigravity])",
        "slotKey": -2
      },
      "key": 18
    },
    {
      "code": "if not HoldingCtrl then\nNav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -speedChangeSmall)\nend",
      "filter": {
        "args": [
          {
            "value": "speeddown"
          }
        ],
        "signature": "actionLoop([speeddown])",
        "slotKey": -2
      },
      "key": 19
    },
    {
      "code": "--Nav:toggleBoosters()\n-- Dodgin's Don't Die Rocket Govenor - Cruise Control Edition\nisboosting = not isboosting\nif(isboosting) then unit.setEngineThrust('rocket_engine',1)\nelse unit.setEngineThrust('rocket_engine',0)\nend",
      "filter": {
        "args": [
          {
            "value": "booster"
          }
        ],
        "signature": "actionStart([booster])",
        "slotKey": -2
      },
      "key": 20
    },
    {
      "code": "if not HoldingCtrl then\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, speedChangeLarge)\nelse\nIncrementAutopilotTargetIndex()\nend",
      "filter": {
        "args": [
          {
            "value": "speedup"
          }
        ],
        "signature": "actionStart([speedup])",
        "slotKey": -2
      },
      "key": 21
    },
    {
      "code": "if not HoldingCtrl then\nNav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, speedChangeSmall)\nend",
      "filter": {
        "args": [
          {
            "value": "speedup"
          }
        ],
        "signature": "actionLoop([speedup])",
        "slotKey": -2
      },
      "key": 22
    },
    {
      "code": "if not HoldingCtrl then\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -speedChangeLarge)\nelse\nDecrementAutopilotTargetIndex()\nend",
      "filter": {
        "args": [
          {
            "value": "speeddown"
          }
        ],
        "signature": "actionStart([speeddown])",
        "slotKey": -2
      },
      "key": 23
    },
    {
      "code": "Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)",
      "filter": {
        "args": [
          {
            "value": "stopengines"
          }
        ],
        "signature": "actionStart([stopengines])",
        "slotKey": -2
      },
      "key": 24
    },
    {
      "code": "if gyro ~= nil then\ngyro.toggle()\nGyroIsOn = gyro.getState() == 1\nend",
      "filter": {
        "args": [
          {
            "value": "option9"
          }
        ],
        "signature": "actionStart([option9])",
        "slotKey": -2
      },
      "key": 25
    },
    {
      "code": "upAmount = upAmount - 1\nNav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)",
      "filter": {
        "args": [
          {
            "value": "down"
          }
        ],
        "signature": "actionStart([down])",
        "slotKey": -2
      },
      "key": 26
    },
    {
      "code": "OldButtonMod = HoldAltitudeButtonModifier\nif AltitudeHold then\nHoldAltitude = HoldAltitude + HoldAltitudeButtonModifier\nelse\nNav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)\nend",
      "filter": {
        "args": [
          {
            "value": "groundaltitudeup"
          }
        ],
        "signature": "actionStart([groundaltitudeup])",
        "slotKey": -2
      },
      "key": 27
    },
    {
      "code": "upAmount = upAmount + 1\nNav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)",
      "filter": {
        "args": [
          {
            "value": "down"
          }
        ],
        "signature": "actionStop([down])",
        "slotKey": -2
      },
      "key": 28
    },
    {
      "code": "if AltitudeHold then\nHoldAltitudeButtonModifier = OldButtonMod\nend",
      "filter": {
        "args": [
          {
            "value": "groundaltitudeup"
          }
        ],
        "signature": "actionStop([groundaltitudeup])",
        "slotKey": -2
      },
      "key": 29
    },
    {
      "code": "if AltitudeHold then\nHoldAltitude = HoldAltitude + HoldAltitudeButtonModifier\nHoldAltitudeButtonModifier = HoldAltitudeButtonModifier * 1.05\nelse\nNav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)\nend",
      "filter": {
        "args": [
          {
            "value": "groundaltitudeup"
          }
        ],
        "signature": "actionLoop([groundaltitudeup])",
        "slotKey": -2
      },
      "key": 30
    },
    {
      "code": "OldButtonMod = HoldAltitudeButtonModifier\nif AltitudeHold then\nHoldAltitude = HoldAltitude - HoldAltitudeButtonModifier\nelse\nNav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)\nend",
      "filter": {
        "args": [
          {
            "value": "groundaltitudedown"
          }
        ],
        "signature": "actionStart([groundaltitudedown])",
        "slotKey": -2
      },
      "key": 31
    },
    {
      "code": "if AltitudeHold then\nHoldAltitude = HoldAltitude - HoldAltitudeButtonModifier\nHoldAltitudeButtonModifier = HoldAltitudeButtonModifier * 1.05\nelse\nNav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)\nend",
      "filter": {
        "args": [
          {
            "value": "groundaltitudedown"
          }
        ],
        "signature": "actionLoop([groundaltitudedown])",
        "slotKey": -2
      },
      "key": 32
    },
    {
      "code": "if AltitudeHold then\nHoldAltitudeButtonModifier = OldButtonMod\nend",
      "filter": {
        "args": [
          {
            "value": "groundaltitudedown"
          }
        ],
        "signature": "actionStop([groundaltitudedown])",
        "slotKey": -2
      },
      "key": 33
    },
    {
      "code": "IncrementAutopilotTargetIndex()",
      "filter": {
        "args": [
          {
            "value": "option1"
          }
        ],
        "signature": "actionStart([option1])",
        "slotKey": -2
      },
      "key": 34
    },
    {
      "code": "DecrementAutopilotTargetIndex()",
      "filter": {
        "args": [
          {
            "value": "option2"
          }
        ],
        "signature": "actionStart([option2])",
        "slotKey": -2
      },
      "key": 35
    },
    {
      "code": "if hideHudOnToggleWidgets then\nif showHud then\nshowHud = false\nelse\nshowHud = true\nend\nend\nToggleWidgets()",
      "filter": {
        "args": [
          {
            "value": "option3"
          }
        ],
        "signature": "actionStart([option3])",
        "slotKey": -2
      },
      "key": 36
    },
    {
      "code": "flush()",
      "filter": {
        "args": [],
        "signature": "flush()",
        "slotKey": -2
      },
      "key": 37
    },
    {
      "code": "    function DisplayMessage(newContent, displayText)\n        if displayText ~= \"empty\" then\n            newContent[#newContent + 1] = string.format(\"<text x='50%%' y='355' font-size='40' fill='red' text-anchor='middle' font-family='Montserrat' style='font-weight:normal'>%s</text>\", displayText)\n        end\n        if msgTimer ~= 0 then \n            unit.setTimer(\"msgTick\", msgTimer)\n            msgTimer = 0\n        end     \n    end\n\n    function updateDistance()\n        local curTime = system.getTime()\n        local velocity = vec3(core.getWorldVelocity())\n        local spd = vec3(velocity):len()\n        local elapsedTime = curTime - lastTravelTime\n        if(spd > 1.38889) then\n            spd = spd / 1000\n            local newDistance = spd * (curTime - lastTravelTime)\n            totalDistanceTravelled = totalDistanceTravelled + newDistance\n            totalDistanceTrip = totalDistanceTrip + newDistance\n        end\n        flightTime = flightTime + elapsedTime\n        totalFlightTime = totalFlightTime + elapsedTime\n        lastTravelTime = curTime\n    end\n\n    function updateMass()\n        local totMass = 0\n        for k in pairs(elementsID) do\n            totMass = totMass + core.getElementMassById(elementsID[k])\n        end\n        return totMass\n    end",
      "filter": {
        "args": [],
        "signature": "start()",
        "slotKey": -2
      },
      "key": 38
    },
    {
      "code": "Nav:update()",
      "filter": {
        "args": [],
        "signature": "update()",
        "slotKey": -2
      },
      "key": 39
    },
    {
      "code": "gearExtended = not gearExtended\nif gearExtended then\nif AltitudeHold and (vBooster or hover) and unit.getAtmosphereDensity() > 0 then -- If they extend while holding and we can get distance, land\nAutoTakeoff = false\nAutoLanding = true -- But never land from space of course\ngearExtended = false -- Don't actually do it\nNav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 0)\nelse\nNav.control.extendLandingGears()\nNav.axisCommandManager:setTargetGroundAltitude(0)\nend\nelse\nNav.control.retractLandingGears()\nNav.axisCommandManager:setTargetGroundAltitude(TargetHoverHeight)\nend",
      "filter": {
        "args": [
          {
            "value": "gear"
          }
        ],
        "signature": "actionStart([gear])",
        "slotKey": -2
      },
      "key": 40
    },
    {
      "code": "pitchInput = pitchInput + 1",
      "filter": {
        "args": [
          {
            "value": "forward"
          }
        ],
        "signature": "actionStop([forward])",
        "slotKey": -2
      },
      "key": 41
    },
    {
      "code": "if Nav.control.isAnyHeadlightSwitchedOn() == 1 then\nNav.control.switchOffHeadlights()\nelse\nNav.control.switchOnHeadlights()\nend",
      "filter": {
        "args": [
          {
            "value": "light"
          }
        ],
        "signature": "actionStart([light])",
        "slotKey": -2
      },
      "key": 42
    },
    {
      "code": "pitchInput = pitchInput - 1",
      "filter": {
        "args": [
          {
            "value": "forward"
          }
        ],
        "signature": "actionStart([forward])",
        "slotKey": -2
      },
      "key": 43
    },
    {
      "code": "pitchInput = pitchInput + 1",
      "filter": {
        "args": [
          {
            "value": "backward"
          }
        ],
        "signature": "actionStart([backward])",
        "slotKey": -2
      },
      "key": 44
    },
    {
      "code": "pitchInput = pitchInput - 1",
      "filter": {
        "args": [
          {
            "value": "backward"
          }
        ],
        "signature": "actionStop([backward])",
        "slotKey": -2
      },
      "key": 45
    },
    {
      "code": "rollInput = rollInput + 1",
      "filter": {
        "args": [
          {
            "value": "right"
          }
        ],
        "signature": "actionStart([right])",
        "slotKey": -2
      },
      "key": 46
    },
    {
      "code": "rollInput = rollInput - 1",
      "filter": {
        "args": [
          {
            "value": "left"
          }
        ],
        "signature": "actionStart([left])",
        "slotKey": -2
      },
      "key": 47
    },
    {
      "code": "rollInput = rollInput + 1",
      "filter": {
        "args": [
          {
            "value": "left"
          }
        ],
        "signature": "actionStop([left])",
        "slotKey": -2
      },
      "key": 48
    },
    {
      "code": "yawInput = yawInput - 1",
      "filter": {
        "args": [
          {
            "value": "yawright"
          }
        ],
        "signature": "actionStart([yawright])",
        "slotKey": -2
      },
      "key": 49
    },
    {
      "code": "yawInput = yawInput + 1",
      "filter": {
        "args": [
          {
            "value": "yawright"
          }
        ],
        "signature": "actionStop([yawright])",
        "slotKey": -2
      },
      "key": 50
    },
    {
      "code": "rollInput = rollInput - 1",
      "filter": {
        "args": [
          {
            "value": "right"
          }
        ],
        "signature": "actionStop([right])",
        "slotKey": -2
      },
      "key": 51
    },
    {
      "code": "Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)",
      "filter": {
        "args": [
          {
            "value": "straferight"
          }
        ],
        "signature": "actionStart([straferight])",
        "slotKey": -2
      },
      "key": 52
    },
    {
      "code": "yawInput = yawInput - 1",
      "filter": {
        "args": [
          {
            "value": "yawleft"
          }
        ],
        "signature": "actionStop([yawleft])",
        "slotKey": -2
      },
      "key": 53
    },
    {
      "code": "yawInput = yawInput + 1",
      "filter": {
        "args": [
          {
            "value": "yawleft"
          }
        ],
        "signature": "actionStart([yawleft])",
        "slotKey": -2
      },
      "key": 54
    },
    {
      "code": "Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)",
      "filter": {
        "args": [
          {
            "value": "straferight"
          }
        ],
        "signature": "actionStop([straferight])",
        "slotKey": -2
      },
      "key": 55
    },
    {
      "code": "Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)",
      "filter": {
        "args": [
          {
            "value": "strafeleft"
          }
        ],
        "signature": "actionStart([strafeleft])",
        "slotKey": -2
      },
      "key": 56
    },
    {
      "code": "Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)",
      "filter": {
        "args": [
          {
            "value": "strafeleft"
          }
        ],
        "signature": "actionStop([strafeleft])",
        "slotKey": -2
      },
      "key": 57
    },
    {
      "code": "upAmount = upAmount - 1\nNav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)",
      "filter": {
        "args": [
          {
            "value": "up"
          }
        ],
        "signature": "actionStop([up])",
        "slotKey": -2
      },
      "key": 58
    },
    {
      "code": "upAmount = upAmount + 1\nNav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)",
      "filter": {
        "args": [
          {
            "value": "up"
          }
        ],
        "signature": "actionStart([up])",
        "slotKey": -2
      },
      "key": 59
    },
    {
      "code": "if Nav.control.isRemoteControlled() == 0 and freeLookToggle then\nif system.isViewLocked() == 1 then\nsystem.lockView(0)\nelse\nsystem.lockView(1)\nend\nelseif Nav.control.isRemoteControlled() == 0 and not freeLookToggle and userControlScheme == \"Keyboard\" then\nsystem.lockView(1)\nend",
      "filter": {
        "args": [
          {
            "value": "lalt"
          }
        ],
        "signature": "actionStart([lalt])",
        "slotKey": -2
      },
      "key": 60
    },
    {
      "code": "if Nav.control.isRemoteControlled() == 0 and not freeLookToggle and userControlScheme == \"Keyboard\" then\nsystem.lockView(0)\nend",
      "filter": {
        "args": [
          {
            "value": "lalt"
          }
        ],
        "signature": "actionStop([lalt])",
        "slotKey": -2
      },
      "key": 61
    },
    {
      "code": "if system.isViewLocked() == 1 then\nHoldingCtrl = false\nsimulatedX = 0\nsimulatedY = 0 -- Reset for steering purposes\nsystem.lockView(PrevViewLock)\nelseif Nav.control.isRemoteControlled() == 1 and ShiftShowsRemoteButtons then\nHoldingCtrl = false\nAnimated = false\nAnimating = false\nend",
      "filter": {
        "args": [
          {
            "value": "lshift"
          }
        ],
        "signature": "actionStop([lshift])",
        "slotKey": -2
      },
      "key": 62
    },
    {
      "code": "if system.isViewLocked() == 1 then\nHoldingCtrl = true\nPrevViewLock = system.isViewLocked()\nsystem.lockView(1)\nelseif Nav.control.isRemoteControlled() == 1 and ShiftShowsRemoteButtons then\nHoldingCtrl = true\nAnimated = false\nAnimating = false\nend",
      "filter": {
        "args": [
          {
            "value": "lshift"
          }
        ],
        "signature": "actionStart([lshift])",
        "slotKey": -2
      },
      "key": 63
    }
  ],
  "methods": [],
  "events": []
}
